<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conteúdo Estudo JS</title>
    <link rel="stylesheet" href="./styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>

<body>
  <nav class="navbar">
    <ul class="nav-links">
        <header>
          <h1>JavaScript</h1>
        </header> 

        <li><a href="#comentario">comentario</a></li>
        <li><a href="#declarar_variaveis">declarar variáveis</a></li>
        <li><a href="#armazenar_valores">armazenar valores</a></li>
        <li><a href="#atribuir_valor_para_outra_var">atribuir valor para outra var</a></li>
        <li><a href="#inicializar_var">inicializar var</a></li>
        <li><a href="#declara_var_string">declara var string</a></li>
        <li><a href="#var_nao_inicializada">var nao inicializada</a></li>
        <li><a href="#sensibilidade_caractere">sensibilidade caractere</a></li>
        <li><a href="#variaveis_leitura_const">variáveis leitura const</a></li>
        <li><a href="#adicionar_dois_numeros">adicionar dois numeros</a></li>
        <li><a href="#subtrair_numero">subtrair numero</a></li>
        <li><a href="#multiplicar">multiplicar</a></li>
        <li><a href="#dividir">dividir</a></li>
        <li><a href="#incremento">incremento</a></li>
        <li><a href="#decremento">decremento</a></li>
        <li><a href="#decimais">decimais</a></li>
        <li><a href="#multiplicar_decimal">multiplicar decimal</a></li>
        <li><a href="#dividir_decimal">dividir decimal</a></li>
        <li><a href="#resto_divisao">resto divisão</a></li>
        <li><a href="#atribuir_modo_composto_adicao">atribuir modo composto adição</a></li>
        <li><a href="#atribuir_modo_composto_subtracao">atribuir modo composto subtração</a></li>
        <li><a href="#atribuir_modo_composto_multiplicacao">atribuir modo composto multiplição</a></li>
        <li><a href="#atribuir_modo_composto_divisao">atribuir modo composto divisão</a></li>
        <li><a href="#aspas_dentro_aspas">aspas dentro aspas</a></li>
        <li><a href="#string_aspas_simples">string aspas simples</a></li>
        <li><a href="#escapar_strings">escapar strings</a></li>
        <li><a href="#concatenar_com_operador_adicao">concatenar com operador adição</a></li>
        <li><a href="#concatenar_com_operador_adicao_igual">concatenar com operador adição igual</a></li>
        <li><a href="#criar_strings_com_variaveis">criar strings com variáveis</a></li>
        <li><a href="#adicionar_variaveis_para_strin">adicionar variáveis para string</a></li>
        <li><a href="#encontrar_o_tamanho_string">encontrar o tamanho string</a></li>
        <li><a href="#encontrar_o_primeiro_caractere">encontrar o primeiro caractere</a></li>
        <li><a href="#imutabilidade_das_strings">imutabilidade das strings</a></li>
        <li><a href="#encontrar_o_enesimo_caractere">encontrar o enesimo caractere</a></li>
        <li><a href="#encontrar_o_ultimo_caractere">encontrar o ultimo caractere</a></li>
        <li><a href="#enesimo_caractere_antes_do_ultimo">enesimo caractere antes do ultimo</a></li>
        <li><a href="#preencher_espacos_em_branco">preencher espacos em branco</a></li>
        <li><a href="#armazenar_multiplos_valores">armazenar multiplos valores</a></li>
        <li><a href="#aninhar_um_array_em_outro_array">aninhar um array em outro array</a></li>
        <li><a href="#acessar_array_de_dados">acessar array de dados</a></li>
        <li><a href="#modificar_dados_de_array">modificar dados de array</a></li>
        <li><a href="#acessar_arrays_multidimensionais">acessar arrays multidimensionais</a></li>
        <li><a href="#manipular_arrays_com_o_metodo_push">manipular arrays com metodo push</a></li>
        <li><a href="#manipular_arrays_com_o_metodo_pop">manipular arrays com metodo pop</a></li>
        <li><a href="#manipular_arrays_com_o_metodo_shift">manipular arrays com metodo shift</a></li>
        <li><a href="#manipular_arrays_com_o_metodo_unshift">manipular arrays com metodo unshift</a></li>
        <li><a href="#criar_lista_de_compras">criar lista de compras</a></li>
        <li><a href="#escrever_javascript_reutilizavel_com_funcoes">escrever javascript reutilizavel com funcoes</a></li>
        <li><a href="#passar_valores_para_funcoes_com_argumentos">passar valores para funcoes com argumentos</a></li>
        <li><a href="#retornar_um_valor_de_uma_funcao_com_return">retornar um valor de uma funcao com return</a></li>
        <li><a href="#conhecer_o_escopo_global_e_funcoes">conhecer o escopo global e funcoes</a></li>
        <li><a href="#conhecer_o_escopo_local_e_funcoes">conhecer o escopo local e funcoes</a></li>
        <li><a href="#diferenciar_escopo_global_e_local_em_funcoes">diferenciar escopo global e local em funcoes</a></li>
        <li><a href="#entender_o_valor_undefined_retornado_de_uma_funcao">entender o valor undefined retornado de uma funcao</a></li>
        <li><a href="#atribuir_com_o_valor_retornado">atribuir com valor retornado</a></li>
        <li><a href="#ficar_na_linha">ficar na linha</a></li>
        <li><a href="#entender-valores-booleanos">entender valores booleanos</a></li>
        <li><a href="#usar-logica-condicional-com-instrucoes-if">usar logica condicional com instrucoes if</a></li>
        <li><a href="#comparar_com_operador_de_igualdade">comparar com operador de igualdade</a></li>
        <li><a href="#comparar_com_operador_de_igualdade_estrita">comparar com operador de igualdade estrita</a></li>
        <li><a href="#praticar_comparacao_diferentes_valores">praticar comparacao diferentes valores</a></li>
        <li><a href="#comparar_com_operador_desigualdade">comparar com operador desigualdade</a></li>
        <li><a href="#comparar_com_o_operador_desigualdade_estrita">Comparar com operador de desigualdade estrita</a></li>
        <li><a href="#comparar_com_o_operador_maior_que">Comparar com operador maior que</a></li>
        <li><a href="#comparar_com_operador_maior_ou_igual">Comparar com operador maior ou igual</a></li>
        <li><a href="#comparar_com_operador_menor_que">Comparar com operador menor que</a></li>
        <li><a href="#comparar_com_operador_menor_ou_igual">Comparar com operador menor ou igual</a></li>
        <li><a href="#comparar_com_operador_logico_and">Comparar com o operador lógico AND</a></li>
        <li><a href="#comparar_com_operador_logico_or">Comparar com o operador lógico OR</a></li>
        <li><a href="#introduzir_instrucoes_else">Introduzir instruções else</a></li>
        <li><a href="#introduzir_instrucoes_else_if">Introduzir instruções else if</a></li>
        <li><a href="#usar_a_ordem_logica_em_instrucoes_if_else">Usar a ordem lógica em instruções if else</a></li>
        <li><a href="#encadear_instrucoes_if_else">Encadear instruções if else</a></li>
        <li><a href="#jogar_golfe_de_codigo">Jogar golfe de código</a></li>
        <li><a href="#selecionar_entre_varias_opcoes_com_instrucoes_switch">Selecionar entre várias opções</a></li>
        <li><a href="#adicionar_uma_opcao_padrão_em_instrucoes_switch">Adicionar uma opção padrão em instruções switch</a></li>
        <li><a href="#lidar_com_varias_opções_idênticas_em_instrucoes_switch">Lidar com várias opções idênticas em instruções switch</a></li>
        <li><a href="#substituir_cadeias_de_if_else_por_switch">Substituir cadeias de if else por switch</a></li>
        <li><a href="#retornar_valores_booleanos_das_funcoes">Retornar valores booleanos das funções</a></li>
        <li><a href="#contar_cartas">Contar Cartas</a></li>
        <li><a href="#criar_objetos">Criar Objetos</a></li>
        <li><a href="#acessar_propriedades_de_objetos_notacao_de_pontos">Acessar propriedades de objeto com notação de pontos</a></li>
        <li><a href="#acessar_propriedades_de_objeto_notacao_de_colchetes">Acessar propriedades de objetos com notação de colchetes</a></li>
        <li><a href="#acessar_propriedades_de_objetos_variaveis">Acessar propriedades de objetos com variáveis</a></li>
        <li><a href="#atualizar_propriedades_do_objeto">Atualizar propriedades do objeto</a></li>
        <li><a href="#adicionar_novas_propriedades_para_objeto">Adicionar novas propriedades para um objeto</a></li>
        <li><a href="#excluir_propriedades_de_objeto">Excluir propriedades de um objeto</a></li>
        <li><a href="#usar_objetos_para_pesquisas">Usar objetos para pesquisas</a></li>
        <li><a href="#testar_objetos_por_propriedades">Testar objetos por propriedades</a></li>
        <li><a href="#manipular_objetos_complexos">Manipular objetos complexos</a></li>
        <li><a href="#acessar_objetos_aninhados">Acessar objetos aninhados</a></li>
        <li><a href="#acessar_arrays_aninhados">Acessar arrays aninhados</a></li>
        <li><a href="#exibir_uma_colecao_de_discos">Exibir uma coleção de discos</a></li>
        <li><a href="#iterar_com_lacos_while">Iterar com laços while</a></li>
        <li><a href="#iterar_com_lacos_for">Iterar com laços for</a></li>
        <li><a href="#iterar_numeros_impares_com_laco_for">Iterar números ímpares com laço for</a></li>
        <li><a href="#contar_para_tras_com_laco_for">Contar para trás com um laço for</a></li>
        <li><a href="#iterar_atraves_array_laco_for">Iterar através de array laço for</a></li>
    </ul>
        
    <div id="menuBtn">
        <div class="menuBtn">
            <div class="line1"></div>
            <div class="line2"></div>
            <div class="line3"></div>
        </div>
    </div>
  </nav>  

  <main>
    <section id="comentario">
        <header>
            <h2>comentário</h2>
        </header>
        
        <h3>O que são e quais as formas de comentar um código?</h3>

        <p>Comentários são linhas de código ou informações adicionais que podem descrever o que determinada parte do código vai fazer. O JavaScript também vai ignorar o comentário entendendo que não é um código.</p>

        <p>Existem duas maneiras de fazer comentários em JavaScript</p>

        <p>comentário de uma linha usando // que dirá ao JavaScript pra ignorar o que tiver na mesma linha após as duas barras.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Este é um comentário de uma linha
        </pre>
        </div>

        <p>Comentário em várias linhas uando /* antes e */ depois do conteúdo</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        /* Este é um commentário
        de multiplas
        linhas */
        </pre>
        </div>

        <p>Crie o habito de comentar partes do código quando você estiver desenvolvendo uma aplicação, pois isso facilitará a manutenção futura, e qualquer pessoa que tiver acesso saberá o que o código irá fazer.</p>
    </section>

    <section id="declarar_variaveis">
        <header>
            <h2>declarar variáveis</h2>
        </header>
        
        <h3>O que é uma variável?</h3>
        
        <p>É um tipo de dado. Em JavaScript por exemplo existem 8 tipos:</p>
        
        <h3>Tipos de dados</h3>

        <ul>
            <li>undefined</li>
            <li>null</li>
            <li>boolean</li>
            <li>string</li>
            <li>symbol</li>
            <li>bigint</li>
            <li>number</li>
            <li>object</li>
        </ul>
        
        <p>Um computador distingue números que estiverem fora das aspas como números, mas se estiver dentros de "" será considerado como texto.</p>
        
        <p>Portanto para fazer calculos em JavaScript não esquecer de usar números fora de aspas</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        let numero = 1 + 2;
        </pre>
        </div>
        
        <p class="resultado">O resultado será 3</p>
        
        <p>Mas se estiver dentro de aspas</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        let numero = "1 + 2";
        </pre>
        </div>           
        
        <p class="resultado">O resultado apresentado será 1 + 2</p>
        
    </section>

    <section id="armazenar_valores">
        <header>
            <h2>armazenar valores</h2>
        </header>
        <h3>Como armazenar uma variável?</h3>
        
        <p>Uma variável em JavaScript pode ser armazenada usando o operador de atribuição (=).</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        minhaVariavel = 5;
        </pre>
        </div>
        
        <p>Tudo que tiver depois do operador (=) será executado primeiro para depois ser atribuido à variável.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        var minhaVariavel;
        minhaVariavel = 5;
        </pre>
        </div>
        
        <p>A variável <span class="verde">minhaVariavel</span> foi criada, depois o valor <span class="verde">5</span> foi atribuido, e se <span class="verde">minhaVariavel</span> for chamada no programa irá aparecer como <span class="verde">5</span>.</p>
        
        
    </section>

    <section id="atribuir_valor_para_outra_var">
        <header>
            <h2>atribuir valor para outra var</h2>
        </header>

        <p>Se uma variável tiver recebido valor podemos usar ela como atributo para outra variável</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        var myVar;
        myvar = 5;
        var myNum;
        myNum = myVar;
        </pre>
        </div>

        <p>Primeiro foi criada uma variável <span class="verde">myVar</span> e atribuido um valor <span class="verde">5</span> Após criar a variável <span class="verde">myNum</span> que recebeu a variável <span class="verde">myVar</span> ela passou a valer <span class="verde">5</span> também, pois esse é o valor que tinha sido atribuido à <span class="verde">myVar</span>. Se por acaso trocarmos o valor de <span class="verde">myVar</span> automáticamente será alterado o valor de <span class="verde">myNum</span>.</p>

    </section>

    <section id="inicializar_var">
        <header>
            <h2>inicializar var</h2>
        </header>

        <p>Para inicializar uma variável basta atribuir uma valor no momento em que ela está sendo declarada</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        var minhaVariavel = 10 + 2;
        </pre>
        </div>        
        
        <p>Se chamar <span class="verde">minhavariavel</span> irá mostrar o seguinte resultado:</p>
        
        <p>12</p>

    </section>

    <section id="declara_var_string">
        <header>
            <h2>declarar var string</h2>
        </header>

        <p>Declarar uma variável do tipo <span class="verde">String</span> precisa atribuir algum valor entre aspas no momento em que ela está sendo declarada.</p>

        <p class="resultado">O valor declarado como String pode ser tanto numérico como qualquer outro caractere</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        var minhaVariavel = "Minha variável";
        ou
        var minhaVariavel_2 = "10 + 2";
        </pre>
        </div>        
        
        <p>Se chamar as variáveis <span class="verde">minhavariavel</span> e <span class="verde">minhaVariavel_2</span>irá mostrar:</p>
        
        <p>Minha variável<br>10 + 2</p>

        <p class="resultado">Percebeu que se atribuir números em uma variável do tipo String será apresentado o resultado como texto, e não será feito calculos?</p>

    </section>

    <section id="var_nao_inicializada">
        <header>
            <h2>var nao inicializada</h2>
        </header>

        <p>Quando uma variável em JavaScript é declarada e nenhum valor é atribuido à ela, seu valor inicial será <span class="verde"> undefined</span> que em português significa indefinido.</p>      
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        let numero;
        </pre>
        </div>   
        
        <p>Se chamar essa variável <span class="verde">numero</span> no console ou pedir para imprimir na tela o resultado será:</p>
        
        <p class="resultado">undefined</p>

    </section>

    <section id="sensibilidade_caractere">
        <header>
            <h2>sensibilidade caractere</h2>
        </header>

        <p>Em JavaScript tanto os nomes de variáveis quanto de funções serão sensíveis a caracteres maiúsculos e minúsculos.</p>

        <p>Uma variável "MINHAVARIAVEL" é diferente de "minhavariavel", isso significa que podemos usar a capitalização para diferenciamos variáveis, mas a melhor pratica é usar o <span class="verde">camelCase</span>, ou seja, inicial a variável com letra minúscula seguida de letra maiúscula caso tenha duas palavras</p>           
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        var duasPalavras;
        var outroExemploSimples;
        var maisUmExemploTetra
        </pre>
        </div>

    </section>

    <section id="variaveis_leitura_const">
        <header>
            <h2>variáveis leitura const</h2>
        </header>

            <h3>Declarar variáveis somente de leitura com a palavra-chave const</h3>

            <p>Na versão ES6 além da palavra-chave <span class="verde">let</span> também podemos usar <span class="verde">const</span> que é outra palavra-chave.</p>
            
            <p>Uma vez atribuido um valor para variável <span class="verde">const</span>, esse valor não poderá ser alterado e servirá apenas para leitura.</p>

            <p>Sendo assim, quando precisar atribuir um valor fixo que não haverá necessidade de reatribuição podemos usar a palavra-chave <span class="verde">const</span>, e caso acidentalmente tentarmos reatribuir outro valor o console exibirá um erro.</p>

            <p>Uma boa prática é usar nomes em letras maiúsculas para valores imutáveis.</p>
        
            <div class="exemplo">
            <h4>exemplo:</h4>
            <pre>
            const LINGUAGEM = "JavaScript";
            </pre>
            </div>              
    </section>

    <section id="adicionar_dois_numeros">
        <header>
            <h2>adicionar dois numeros</h2>
        </header>

        <p>Em JavaScript tem um tipo de dado que representa um número e esse tipo de dado pode ser declarado como <span class="verde">Number</span>.</p>

        <p>Para adicionar dois números basta utilizar o símbolo + como um operador de adição e quando colocado entre dois números irá realizar um calculo.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const SOMA = 1 + 1;
        </pre>
        </div>
        
        <p>O resultado será:</p>

        <p class="resultado">2</p>

    </section>

    <section id="subtrair_numero">
        <header>
            <h2>subtrair numero</h2>
        </header>

        <h3>Subtrair um número de outro número usando JavaScript</h3>

        <p>também podemos subtrair um número de outro.</p>

        <p>Basta usar o símbolo - para fazer subtração.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const SUBTRACAO = 2 - 1;
        </pre>
        </div>

        <p>SUBTRACAO terá o valor de 1.</p>

    </section>

    <section id="multiplicar">
        <header>
            <h2>multiplicar</h2>
        </header>

            <p>Para realizar uma multiplicação entre números usa-se o símbolo asterístico (*)</p>
            
            <div class="exemplo">
            <h4>exemplo:</h4>
            <pre>
            cont MULTIPLICACAO = 2 * 1234;
            </pre>
            </div>

            <p>Essa é fácil vai... Nem vou mostrar o result 😊</p>

    </section>

    <section id="dividir">
        <header>
            <h2>dividir</h2>
        </header>

        <h3>E aquele doce gostoso que você compra e quer dividir?</h3>
            
        <p>Sério que também consigo descobrir o resultado de uma divisão usando JavaScript? Yes!</p>

        <p>Se usarmos o símbolo de barra entre números o JavaScript entenderá que é para dividir.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const DIVISAO = 598745 / 98524;
        </pre>
        </div>
            
        <p class="resultado">resultado?</p>

        <p>Essa vou deixar pra você fazer, tah? 😅</p>

    </section>

    <section id="incremento">
        <header>
            <h2>incremento</h2>
        </header>

        <h3>Incrementar um número com JavaScript.</h3>

        <p>Você pode facilmente incrementar ou adicionar 1 à variável com operador ++.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>    
        <pre>
        var i = 1;            
        i++;    
        </pre>
        </div>
        
        <p>resultado:</p>
        <p class="resultado">2</p>

        <p>é o equivalente a:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        i = i + 1;            
        </pre>
        </div>
        
        <p>resultado:</p>
        <p class="resultado">2</p>

        <p>Observação: a linha torna-se i++;,eliminando a necessidade para o sinal de igual (atribuição).</p>

    </section> 

    <section id="decremento">
        <header>
            <h2>decremento</h2>
        </header>

        <h3>Decrementar um número com JavaScript</h3>

        <p>Você pode facilmente decrementar ou diminuir uma variável por um com operador --.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        var i = 1;
        i--;
        </pre>
        </div>
    
        <p>resultado:</p>
        <p class="resultado">0</p>

        <p>é o equivalente a</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        i = i - 1;
        </pre>
        </div>
    
        <p>resultado:</p>
        <p class="resultado">0</p>

        <p>Observação: a linha inteira torna-se i--;, eliminando a necessidade para o sinal de igual (atribuição).</p>

    </section>

    <section id="decimais">
        <header>
            <h2>decimais</h2>
        </header>
        
        <h3>Criar números decimais com JavaScript</h3>

        <p>também é possível armazenar números decimais em variáveis. lembrando que os números decimais são às vezes referidos como números de ponto flutuante ou floats.</p>
        
        <p>Observação: ao computar números, eles são calculados com precisão finita. Operações que usam pontos flutuantes podem levar a resultados diferentes do resultado desejado. Se você estiver obtendo um desses resultados, abra um tópico no fórum do freeCodeCamp.</p>

    </section>

    <section id="multiplicar_decimal">
        <header>
            <h2>multiplicar decimal</h2>
        </header>
        
        <h3>Multiplicar dois decimais com JavaScript</h3>

        <p>Em JavaScript, você também pode realizar cálculos com números decimais, assim como com números inteiros.</p>

    </section>

    <section id="dividir_decimal">
        <header>
            <h2>dividir decimal</h2>
        </header>

        <h3>Dividir um decimal por outro com JavaScript</h3>
            
        <p>Agora vamos dividir um decimal por outro.</p>
        
        <p>Modifique 0.0 para que a variável quotient seja igual a 2.2.</p>    
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const quotient = 4.4 / 2.0;
        </pre>
        </div>

        <p>resultado: </p>
        <p class="resultado">2.2</p>

    </section>

    <section id="resto_divisao">
        <header>
            <h2>resto divisão</h2>
        </header>

        <h3>Descobrir o resto em JavaScript</h3>

        <p>O operador de resto % retorna o resto da divisão de dois números.<p>
                    
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        5 % 2 = 1
        5 / 2 = 2 resto 1
        2 * 2 = 4
        5 - 4 = 1
        </pre>
        </div>

        <h3>Uso</h3>
        <p>Na matemática, um número pode ser verificado como par ou ímpar por meio do resto da divisão do número por 2. Números pares têm um resto de 0, enquanto números ímpares têm um resto de 1.</p>
                    
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        17 % 2 = 1
        48 % 2 = 0
        </pre>
        </div>

        <p>Observação: o operador de resto às vezes é referido incorretamente como o operador de módulo. É muito semelhante ao módulo, mas não funciona adequadamente com números negativos.</p>

    </section>

    <section id="atribuir_modo_composto_adicao">
        <header>
            <h2>atribuir modo composto adição</h2>
        </header>
        
        <h3>Atribuir de modo composto com adição aumentada</h3>

        <p>Na programação, é comum usar atribuições para modificar o conteúdo de uma variável. Lembre-se de que tudo à direita do sinal de igual é avaliado primeiro, para que possamos dizer:</p>  
                    
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        myVar = myVar + 5;
        </pre>
        </div>

        <p>para adicionar 5 a myVar. Como este é um padrão tão comum, existem operadores que realizam uma operação matemática e atribuição em um passo.</p>

        <p>Um desses operadores é o operador +=.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        let myVar = 1;
        myVar += 5;
        console.log(myVar);
        </pre>
        </div>

        <p>resultado:</p>
        <p class="resultado">6 seria exibido no console.</p>
    </section>

    <section id="atribuir_modo_composto_subtracao">
        <header>
            <h2>atribuir modo composto subtração</h2>
        </header>
        
        <h3>Atribuir de modo composto com subtração aumentada</h3>

        <p>Como o operador +=, -= subtrai um número de uma variável.</p>  
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        myVar = myVar - 5;
        </pre>
        </div>
        
        <p>vai subtrair 5 de myVar. Essa expressão pode ser reescrita assim:</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        myVar -= 5;
        </pre>
        </div>       
    </section>

    <section id="atribuir_modo_composto_multiplicacao">
        <header>
            <h2>atribuir modo composto multiplição</h2>
        </header>

        <h3>Atribuir de modo composto com multiplicação aumentada</h3>

        <p>O operador *= multiplica uma variável por um número.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        myVar = myVar * 5;
        </pre>
        </div>       
        
        <p>multiplicará myVar por 5. Essa expressão pode ser reescrita assim:</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        myVar *= 5;
        </pre>
        </div>       
    </section>

    <section id="atribuir_modo_composto_divisao">
        <header>
            <h2>atribuir modo composto divisão</h2>
        </header>

        <h3>Atribuir de modo composto com divisão aumentada</h3>

        <p>O operador /= divide uma variável por outro número.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        myVar = myVar / 5;
        </pre>
        </div>       
        
        <p>dividirá myVar por 5. Essa expressão pode ser reescrita assim:</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        myVar /= 5;
        </pre>
        </div>       

    </section>

    <section id="aspas_dentro_aspas">
        <header>
            <h2>aspas dentro aspas</h2>
        </header>

        <h3>Escapar aspas literais em strings</h3>

        <p>Quando você estiver definindo uma sequência de caracteres você deve iniciar e terminar com uma aspa simples ou dupla. O que acontece quando você precisa de uma aspa literal: " ou ' dentro de sua string?</p>
        
        <p>Em JavaScript, você pode escapar uma aspa para que não seja considerada como o fim de uma string ao colocar a barra invertida (\) na frente da aspa.</p>  
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const sampleStr = "Alan disse, \"Peter está aprendendo JavaScript\".";
        </pre>
        </div>
        
        <p>Isso sinaliza ao JavaScript que a aspa seguinte não é o fim de uma string, mas que deve aparecer dentro da string. Então, se você fosse imprimir isso no console, você obteria:</p>
        
        <p>resultado:</p>
        <p class="resultado">Alan disse: "Peter está aprendendo JavaScript".</p>
    </section>

    <section id="string_aspas_simples">
        <header>
            <h2>string aspas simples</h2>
        </header>

        <h3>Cercar uma string com aspas simples</h3>

        <p>Valores de string em JavaScript podem ser escritas com aspas simples ou duplas, desde que você comece e termine com mesmo tipo de aspas. Diferente de outras linguagens de programação, aspas simples e duplas funcionam da mesma forma em JavaScript.</p>  
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const doubleQuoteStr = "Esta é uma string"; 
        const singleQuoteStr = 'Esta também é uma string';
        </pre>
        </div>
        
        <p>O motivo pelo qual você pode querer usar um tipo de aspas no lugar da outra é se você vir a querer usar ambas em uma string. Isso pode acontecer se você quiser salvar uma conversa em uma string e ter a conversa entre aspas. Outro uso para isso seria salvar uma tag &lt;a&gt; com vários atributos em aspas, tudo dentro de uma string.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const conversation = 'Finn exclama para Jake: "Algébrico!"';
        </pre>
        </div>
        
        <p>Porém, isso se torna um problema se você precisar usar as aspas mais extremas dentro dela. Lembre-se, uma string tem o mesmo tipo de aspas no início e no final. Mas se você tem aquela mesma aspa em algum lugar no meio, a string vai terminar mais cedo e lançará um erro.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const goodStr = 'Jake pergunta a Finn, "Ei, let\'s go em uma aventura?"'; 
        const badStr = 'Finn responde, "Vamos!"';
        </pre>
        </div>       
        
        <p>Aqui badStr lançará um erro.</p>
        
        <p>Na string goodStr acima, você pode usar ambas as aspas com segurança ao usar a barra invertida \ como um caractere de escapamento.</p>
        
        <p>Observação: a barra invertida \ não deve ser confundida com a barra comum /. Elas não fazem a mesma coisa.</p>
    </section>

    <section id="escapar_strings">
        <header>
            <h2>escapar strings</h2>
        </header>

        <h3>Escapar sequências em strings</h3>

        <p>Aspas não são os únicos caracteres que podem ser escapados dentro de uma string. As sequências de escape permitem que você use caracteres que você não poderia usar em uma string em outras situações.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        Código	Saída
        \'	    aspas simples
        \"	    aspas duplas
        \\	    barra invertida
        \n	    nova linha
        \t	    tab
        \r	    retorno de carro
        \b	    retroceder
        \f	    quebra de página
        </pre>
        </div>
        
        <p>Note que a própria barra invertida deve ser escapada para ser exibida como uma barra invertida.</p>
    </section>

    <section id="concatenar_com_operador_adicao">
        <header>
            <h2>concatenar com operador adição</h2>
        </header>

        <h3>Concatenar strings com operador mais</h3>

        <p>Em JavaScript, quando o operador + é usado com um valor de String, ele é chamado de operador de concatenação. Você pode criar uma nova string a partir de outras strings ao concatenar elas juntos.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        'Meu nome é Alan,' + ' Eu concatenei.'
        </pre>
        </div>
        
        <p>Observação: cuidado com os espaços. A concatenação não adiciona espaços entre strings concatenadas, então você mesmo precisará adicioná-las.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const ourStr = "eu venho primeiro. " + "eu venho depois.";
        </pre>
        </div>   
        
        <p>resultado:</p>
        <p class="resultado">eu venho primeiro eu venho depois.</p>
        A string             
    </section>

    <section id="concatenar_com_operador_adicao_igual">
        <header>
            <h2>concatenar com operador adição igual</h2>
        </header>

        <h3>Concatenar strings com operador mais igual</h3>

        <p>Também podemos usar o operador += para concatenar uma string no final de uma variável string existente. Isso pode ser muito útil para quebrar uma longa string em várias linhas.</p>
        
        <p>Observação: cuidado com os espaços. A concatenação não adiciona espaços entre strings concatenadas, então você mesmo precisará adicioná-los.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        let ourStr = "eu venho primeiro. ";
        ourStr += "eu venho em segundo.";
        </pre>
        </div>
        
        <p>resultado ourStr:</p>
        <p class="resultado">eu venho primeiro. eu venho em segundo</p>  
    </section>

    <section id="criar_strings_com_variaveis">
        <header>
            <h2>criar strings com variaveis</h2>
        </header>

        <h3>Criar strings com variáveis</h3>

        <p>Às vezes, você precisará criar uma string. Usando o operador de concatenação (+), você pode inserir uma ou mais variáveis em uma string que você está criando.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const ourName = "freeCodeCamp";
        const ourStr = "Olá, nosso nome é " + ourName + ", como vai você?";
        </pre>
        </div>
        
        <p>resultado ourStr:</p>
        <p class="resultado">Olá, nosso nome é freeCodeCamp, como vai você?</p>       
    </section>

    <section id="adicionar_variaveis_para_strin">
        <header>
            <h2>adicionar variaveis para string</h2>
        </header>

        <h3>Adicionar variáveis para strings</h3>

        <p>Assim como podemos construir uma string em várias linhas através das strings literais, nós também podemos adicionar as variáveis para a string usando o operador mais igual (+=).</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const anAdjetivo = "incrível!"; 
        let ourStr = "freeCodeCamp is"; 
        ourStr += anAdjetivo;
        </pre>
        </div>
        
        <p>resultado ourStr:</p>
        <p class="resultado">freeCodeCamp é incrível!.</p>
    </section>		
    
    <section id="encontrar_o_tamanho_string">
        <header>
            <h2>encontrar o tamanho estring</h2>
        </header>
        <h3>Encontrar o tamanho de uma string</h3>

        <p>Você pode encontrar o tamanho de um valor de String ao escrever .length após a variável de string ou literal de string.<p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        console.log("Alan Peter".length);
        </pre>
        </div>

        <p>O valor 10 seria exibido no console. Observe que o caractere de espaço entre "Alan" e "Peter" também é contado.</p>          

        <p>Por exemplo, se nós criássemos uma variável const firstName = "Ada", poderíamos descobrir qual o tamanho da string Ada usando a propriedade firstName.length.</p>
    </section>
    
<section id="encontrar_o_primeiro_caractere">
        <header>
            <h2>encontrar o primeiro caractere</h2>
        </header>

        <h3>Usar notação de colchetes para encontrar o primeiro caractere em uma string</h3>

        <p>Notação de colchetes é uma forma de pegar um caractere no índice especificado dentro de uma string.</p>

        <p>A maioria das linguagens de programação modernas, como JavaScript, não começa contando do 1 como humanos fazem. Elas começam no 0. Isso é referido como indexação baseada em zero.</p>

        <p>Por exemplo, o caractere no índice 0 da palavra Charles é C. Então, se const firstName = "Charles", você pode pegar o valor da primeira letra da string usando firstName[0].</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const firstName = "charles";
        const firstLetter = firstName[0];
        </pre>
        </div>

        <p>resultado: </p>
        <p class="resultado">firstLetter teria o valor da string C.</p>
    </section>
    
<section id="imutabilidade_das_strings">
        <header>
            <h2>imutabilidade das strings</h2>
        </header>

        <h3>Entender a imutabilidade das strings</h3>

        <p>Em JavaScript, valores String são imutáveis, o que significa que elas não podem ser alteradas após serem criadas.</p>
            
        <p>Por exemplo, o código a seguir produzirá um erro porque a letra B na cadeia de caracteres Bob não pode ser alterada para a letra J:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        let myStr = "Bob";
        myStr[0] = "J";
        </pre>
        </div>            
            
        <p>Observe que isso não significa que myStr não possa ser reatribuída. A única forma de alterar myStr seria atribuindo a ela um novo valor, deste modo:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        let myStr = "Bob";
        myStr = "Job";
        </pre>
        </div>  
    </section>
    
<section id="encontrar_o_enesimo_caractere">
        <header>
            <h2>encontrar o enesimo caractere</h2>
        </header>

        <h3>Usar notação de colchetes para encontrar o enésimo caractere em uma string</h3>

        <p>Você também pode usar notação de colchetes para pegar caracteres em outras posições em uma string.

        <p>Lembre-se de que computadores começam contando do 0. Então, o primeiro caractere é na verdade o caractere na posição 0.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const firstName = "Ada";
        const secondLetterOfFirstName = firstName[1];
        </pre>
        </div>
            
        <p>secondLetterOfFirstName teria o valor da string d.<p>
    </section>
    
<section id="encontrar_o_ultimo_caractere">
        <header>
            <h2>encontrar o ultimo caractere</h2>
        </header>
        <h3>Usar notação de colchetes para encontrar o último caractere em uma string</h3>

        <p>Para pegar a última letra de uma string, você pode subtrair um do tamanho da string.</p>
            
        <p>Por exemplo, se const firstName = "Ada", você pode pegar o valor da última letra da string ao usar firstName[firstName.length - 1].</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const firstName = "Ada";
        const lastLetter = firstName[firstName.length - 1];
        </pre>
        </div>

        <p>lastLetter teria o valor da string a.</p>

        <div class="exemplo">
            <label>Digite uma palavra. Click em enviar, e veja no resultado: <span class="amarelo">a última letra</span> que foi digitada.</label><br>
            <input type="text" name="txt" id="txt"> 
            <input type="button" value="Enviar" onclick="ultimaLetra()">
            <input id="btnOk" type="reset" value="Apagar" onclick="apagar()">
            <div id="res">Resultado</div>

            <script>
                function ultimaLetra() {
                    let txt = document.getElementById('txt')
                    let res = document.getElementById('res')
                    let t1 = String(txt.value)

                    t1 = t1[t1.length -1]
                    
                    //function valorLetra(){
                        if ((t1 == 'a') || (t1 == 'e') || (t1 == 'i') || (t1 == 'o') || (t1 == 'u')) {
                            res.innerHTML = `A última letra é uma vogal:  <span class='amarelo'>${t1}</span>`    
                        } else {
                            res.innerHTML = "A última letra é uma consoante: <span class='amarelo'>" + t1 + "</sapan>"
                        }
                    //}                        

                    /*if ((t1 != "")) {
                        valorLetra()   
                    } else {
                        alert('Precisa digitar uma plavra ou uma letra!')
                    window.location.reload(false);
                    }*/
                }
                    
                function apagar() {
                    var btnOk = document.getElementById('btnok');
                    btnOk = document.getElementById('txt').value="";
                    window.location.reload(false);
                }
            </script>
        </div>
    </section>
    
<section id="enesimo_caractere_antes_do_ultimo">
        <header>
            <h2>enesimo caractere antes do ultimo</h2>
        </header>

        <h3>Usar notação de colchetes para descobrir o enésimo caractere antes do último em uma string</h3>

        <p>Você pode usar o mesmo princípio que nós acabamos de usar para recuperar o último caractere em uma string, para recuperar o enésimo caractere antes do último caractere.</p>
            
        <p>Por exemplo, você pode pegar o valor da antepenúltima letra da string const firstName = "Augusta" usando firstName[firstName.length - 3]</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const firstName = "Augusta";
        const thirdToLastLetter = firstName[firstName.length - 3];
        </pre>
        </div>
            
        <p>thirdToLastLetter teria o valor da string s.</p>
    </section>
    
<section id="preencher_espacos_em_branco">
        <header>
            <h2>preencher espacos em branco</h2>
        </header>
        
        <h3>Preencher espaços em branco</h3>

        <p>Você recebe frases com algumas palavras faltando, como substantivos, verbos, adjetivos e advérbios. Você então preencherá os pedaços faltantes com palavras de sua escolha de modo que a frase completa faça sentido.</p>
            
        <h3>Considere esta frase:</h3>
            
        <p>It was really ____, and we ____ ourselves ____.</p>
            
        <p>Essa frase possui três pedaços faltando - um <b>adjetivo</b>, um <b>verbo</b> e um <b>advérbio</b>, e nós podemos adicionar palavras de nossa escolha para completar. Em seguida, podemos atribuir a frase completa para uma variável como se segue:</p>
            
        <p>const sentence = "It was really " + "<b>hot</b>" + ", and we " + "<b>laughed</b>" + " ourselves " + "<b>silly</b>" + ".";</p>
    </section>
    
<section id="armazenar_multiplos_valores">
        <header>
            <h2>armazenar multiplos valores</h2>
        </header>
        <h3>Armazenar múltiplos valores em uma variável usando arrays JavaScript</h3>

        <p>Com as variáveis de array em JavaScript, podemos armazenar diversos dados em um único lugar.</p>

        <p>Você começa uma declaração de um array com a abertura de um colchetes, terminando com fechamento do colchetes e colocando vírgulas entre cada entrada, dessa forma:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const sandwich = ["peanut butter", "jelly", "bread"];
        </pre>
        </div>
    </section>
    
<section id="aninhar_um_array_em_outro_array">
        <header>
            <h2>aninhar um array em outro array</h2>
        </header>

        <h3>Aninhar um array em outro array</h3>

        <p>Você também pode aninhar arrays dentro de outros arrays, como abaixo:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const teams = [["Bulls", 23], ["White Sox", 45]];
        </pre>
        </div>

        <p>Isso é chamado um array multidimensional.<p>
    </section>
    
<section id="acessar_array_de_dados">
        <header>
            <h2>acessar array de dados</h2>
        </header>

        <h3>Acessar array de dados com índices</h3>

        <p>Podemos acessar os dados dentro de arrays usando indexes.</p>

        <p>Os índices de um array são escritos na mesma notação com colchetes que as strings usam. Porém, em vez de especificar um caractere, eles estão especificando um item do array. Assim como ocorre com as strings, os arrays usam indexação de base zero, de forma que o primeiro elemento de um array possui índice 0.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const array = [50, 60, 70];
        console.log(array[0]);
        const data = array[1];
        </pre>
        </div>

        <p>O console.log(array[0]) exibirá 50 e data terá o valor de 60.<p>
    </section>
    
<section id="modificar_dados_de_array">
        <header>
            <h2>modificar dados de array</h2>
        </header>

        <h3>Modificar dados de array com índices</h3>

        <p>Ao contrário das strings, as entradas de arrays são mutáveis e podem ser alteradas livremente, mesmo se o array foi declarado com const.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const ourArray = [50, 40, 30];
        ourArray[0] = 15;
        </pre>
        </div>

        <p>ourArray agora tem o valor [15, 40, 30].</p>

        <p>Observação: não deve haver espaços entre o nome do array e os colchetes, como array [0]. Embora JavaScript seja capaz de processar isso corretamente, isso pode confundir outros programadores lendo seu código.</p>
    </section>
    
<section id="acessar_arrays_multidimensionais">
        <header>
            <h2>acessar arrays multidimensionais</h2>
        </header>

        <h3>Acessar arrays multidimensionais com índices</h3>

        <p>Uma maneira de pensar em um array multidimensional é como um array de arrays. Quando você usa colchetes para acessar seu array, o primeiro conjunto de colchetes se refere às entradas no array mais exterior (o primeiro nível), e cada par adicional de colchetes refere-se ao próximo nível de entradas interno.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const arr = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9],
        [[10, 11, 12], 13, 14]
        ];

        const subarray = arr[3];
        const nestedSubarray = arr[3][0];
        const element = arr[3][0][1];
        </pre>
        </div>

        <p>Neste exemplo, subarray tem o valor de [[10, 11, 12], 13, 14], nestedSubarray tem o valor de [10, 11, 12] e element tem o valor de 11.</p>

        <p>Observação: não deve haver nenhum espaço entre o nome do array e os colchetes como array [0][0] e até mesmo array [0] [0] não é permitido. Embora JavaScript seja capaz de processar isso corretamente, isso pode confundir outros programadores lendo seu código.</p>
    </section>
    
<section id="manipular_arrays_com_o_metodo_push">
        <header>
            <h2>manipular arrays com metodo push</h2>
        </header>
        
        <h3>Manipular arrays com método push</h3>

        <p>Um modo fácil de adicionar dados no final de um array é através do método <span class="verde">push()</span>.</p>
            
        <p>O método <span class="verde">push()</span> recebe um ou mais argumentos e os insere no final do array, na ordem em que eles aparecerem. Ele retorna o novo comprimento do array.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const arr1 = [1, 2, 3];
        arr1.push(4, 5);
        
        const arr2 = ["Stimpson", "J", "cat"];
        arr2.push(["happy", "joy"]);
        </pre>
        </div>

        <p>arr1 agora tem o valor de [1, 2, 3, 4, 5] e arr2 tem o valor de ["Stimpson", "J", "cat", ["happy", "joy"]].</p>
    </section>
    
<section id="manipular_arrays_com_o_metodo_pop">
        <header>
            <h2>manipular arrays com metodo pop</h2>
        </header>
        
        <h3>Manipular arrays com método pop</h3>

        <p>Outra forma de alterar os dados em um array é com a função <span class="verde">.pop()</span>.</p>
            
        <p><span class="verde">.pop()</span> é usado para remover um valor do final do array. Nós podemos armazenar esse valor removido atribuindo-o a uma variável. Em outras palavras, <span class="verde">.pop()</span> remove o último elemento de um array e retorna aquele elemento.</p>
        
        <p>Qualquer tipo de entrada pode ser removida de um array - numbers, strings e até mesmo arrays aninhados.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const threeArr = [1, 4, 6];
        const oneDown = threeArr.pop();
        console.log(oneDown);
        console.log(threeArr);
        </pre>
        </div>
        
        <p>O primeiro console.log exibirá o valor 6 e o segundo exibirá o valor [1, 4].</p>
    </section>
    
<section id="manipular_arrays_com_o_metodo_shift">
        <header>
            <h2>manipular arrays com metodo shift</h2>
        </header>
        
        <h3>Manipular arrays com método shift</h3>

        <p><span class="verde">pop()</span> sempre remove o último elemento de um array. E se você quiser remover o primeiro?</p>
        
        <p>É aí que o <span class="verde">.shift()</span> vem a ser útil. Ele funciona da mesma forma que <span class="verde">.pop()</span>, exceto que ele remove o primeiro elemento ao invés do último.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const ourArray = ["Stimpson", "J", ["cat"]];
        const removedFromOurArray = ourArray.shift();
        </pre>
        </div>
        
        <p>removedFromOurArray teria o valor da string Stimpson e ourArray teria o valor de ["J", ["cat"]].</p>
    </section>
    
<section id="manipular_arrays_com_o_metodo_unshift">
        <header>
            <h2>manipular arrays com metodo unshift</h2>
        </header>
        
        <h3>Manipular arrays com método unshift</h3>

        <p>Você pode não apenas usar <span class="verde">shift</span> para remover elementos do início de um array, como também pode usar <span class="verde">unshift</span> para adicionar elementos ao início de um array, ou seja, adicionar elementos na posição inicial do array.</p>
        
        <p><span class="verde">.unshift()</span> funciona exatamente como <span class="verde">.push()</span>, mas, ao invés de adicionar o elemento ao final do array, <span class="verde">unshift()</span> adiciona o elemento no início do array.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const ourArray = ["Stimpson", "J", "cat"];
        ourArray.shift();
        ourArray.unshift("Happy");
        </pre>
        </div>
        
        <p>Após o shift, ourArray teria o valor ["J","cat"]. Após o unshift, ourArray teria o valor ["Happy","J","cat"].</p>
    </section>  
    
    <section id="#criar_lista_de_compras">
        <header> 
            <h2>criar lista de compras</h2>
        </header>
        
        <p>Crie uma lista de compras na variável myList. A lista deve ser um array multidimensional contendo diversos sub-arrays.</p>

        <p>O primeiro elemento em cada sub-array deve conter uma string com nome do item. O segundo elemento deve ser um número representando a quantidade, ou seja,</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>                    
        ["Chocolate Bar", 15]            
        </pre>
        </div>

        <p>resultado:</p>
        <p class="resultado">const myList = [["Arroz", 3], ["Feijão", 2], ["Óleo", 1], ["Café", 1], ["Açucar", 1]];</p>
    </section>
    
    <section id="#escrever_javascript_reutilizavel_com_funcoes">
        <header> 
            <h2>javascript reutilizavel com funcoes</h2>
        </header>

        <h3>Escrever JavaScript reutilizável com funções</h3>

        <p>Em JavaScript, nós podemos dividir nosso código em partes reutilizáveis chamadas de funções.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>                
        function functionName() {
            console.log("Hello World");
            }
        </pre>
        </div>

        <p>Você pode chamar ou invocar essa função ao usar seu nome seguido de parênteses, da seguinte forma: functionName(); Cada vez que a função é chamada, imprimirá no console a mensagem Hello World. Todo o código entre as chaves será executado toda vez que uma função for chamada.</p>
    </section>
    
    <section id="#passar_valores_para_funcoes_com_argumentos">
        <header> 
            <h2>Passar valores para funcoes</h2>
        </header>

        <h3>Passar valores para funções com argumentos</h3>

        <p>Parâmetros são variáveis que atuam como espaços reservados para os valores que são passados para uma função, quando ela é chamada. Quando uma função é definida, normalmente ela é definida junto com um ou mais parâmetros. Os valores reais que são entradas de (ou "passadas" para) uma função quando ela é chamada são conhecidos como argumentos.</p>
            
        <p>Aqui está uma função com dois parâmetros, param1 e param2:<p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>                
        function testFun(param1, param2) {
            console.log(param1, param2);
        }
        </pre>
        </div>
            
        <p>Então podemos chamar o testFun dessa forma: testFun("Hello", "World");. Passamos dois argumentos do tipo string, Hello e World. Dentro da função, param1 será igual à string Hello e param2 será igual à string World. Note que você poderia chamar o testFun novamente com diferentes argumentos e os parâmetros assumiriam o valor dos novos argumentos.</p>

        <p>Criando uma função chamada functionWithArgs que aceita dois argumentos para exibir a soma de seus valores no console de desenvolvimento, e chamando a função com dois números como argumentos.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>                
        function functionWithArgs(num1,num2) {
            console.log(num1+num2)
        }
        
        functionWithArgs(1,2)
        functionWithArgs(7,9)
        </pre>
        </div>
    </section>
    
    <section id="#retornar_um_valor_de_uma_funcao_com_return">
        <header> 
            <h2>retornar um valor de uma funcao com return</h2>
        </header>

        <h3>Retornar um valor de uma função com return</h3>

        <p>Nós podemos passar valores para uma função com argumentos. Você pode usar uma instrução return para enviar um valor para fora de uma função.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>                
        function plusThree(num) {
            return num + 3;
        }
        
        const answer = plusThree(5);
        
        answer tem o valor de 8.
        </pre>
        </div>

        <p>plusThree recebe um argumento para num e retorna um valor igual a num + 3.</p>

        <p>Criando uma função timesFive que aceita um argumento, multiplica ele por 5 e retorna o novo valor.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function timesFive (n) {
            return n * 5
        }
        
        timesFive (5)
        timesFive (2)
        timesFive (0)                
        </pre>
        </div>
    </section> 
    
    <section id="#conhecer_o_escopo_global_e_funcoes">
        <header>
            <h2>conhecer o escopo global e funcoes</h2>
        </header>

        <h3>Conhecer o escopo global e funções</h3>

        <p>Em JavaScript, escopo refere-se à visibilidade de variáveis. Variáveis que são definidas fora de um bloco de função tem o escopo Global. Isso significa que elas podem ser vistas em qualquer lugar no seu código JavaScript.</p>
            
        <p>Variáveis que são declaradas sem a palavra-chave let ou const são automaticamente criadas no escopo global. Isso pode criar consequências indesejadas em outro lugar no seu código ou quando executar uma função novamente. Você sempre deve declarar suas variáveis com let ou const.</p>

        <p>Usando let ou const, declare uma variável global chamada myGlobal fora de qualquer função. Inicialize-a com valor de 10.</p>

        <p>Dentro da função fun1, atribua 5 para oopsGlobal sem usar as palavras-chave var, let ou const.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre> 
        const myGlobal = 10

        function fun1() {
            oopsGlobal = 5
        }

        function fun2() {
            let output = "";
            if (typeof myGlobal != "undefined") {
                output += "myGlobal: " + myGlobal;
            }
                      
            if (typeof oopsGlobal != "undefined") {
                output += " oopsGlobal: " + oopsGlobal;
            }
        
            console.log(output);
        }               
        </pre>
        </div>
    </section> 
    
    <section id="conhecer_o_escopo_local_e_funcoes">
        <header>
            <h2>escopo local e funções</h2>
        </header>
        <h3>Conhecer o escopo local e funções</h3>

        <p>Variáveis que são declaradas dentro de uma função, assim como parâmetros das funções, possuem escopo local. Isso significa que elas são visíveis apenas dentro da função.<p>

        <p>Aqui está uma função myTest com uma variável local chamada loc.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function myTest() {
        const loc = "foo";
        console.log(loc);
        }

        myTest();
        console.log(loc);
        </pre>
        </div>

        <p>A chamada da função myTest() vai exibir a string foo no console. A linha console.log(loc) (fora da função myTest) vai lançar um erro, já que loc não foi definido fora da função.</p>

        <p>Declare uma variável local myVar dentro de myLocalScope e rode os testes.</p>

        <p>Observação: o console ainda exibirá ReferenceError: myVar is not defined, mas isso não causará falha nos testes.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function myLocalScope() {
            let myVar;

        console.log('inside myLocalScope', myVar);
        }
        myLocalScope();

        // Executar e verificar o console
        // myVar não está definida fora do myLocalScope
        console.log('outside myLocalScope', myVar);
        </pre>
        </div>
    </section>

    <section id="diferenciar_escopo_global_e_local_em_funcoes">
        <header>
            <h2>Diferenciar escopo global e local</h2>
        </header>

        <h3>Diferenciar escopo global e local em funções</h3>

        <p>É possível ter as variáveis local e global com mesmo nome. Quando você faz isso, a variável local tem precedência sobre a variável global.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const someVar = "Hat";

        function myFun() {
        const someVar = "Head";
        return someVar;
        }
        </pre>
        </div>

        <p>A função myFun retornará a string Head porque a versão local da variável está presente.</p>

        <p>Adicione uma variável local para a função myOutfit para sobrescrever o valor de outerWear com a string sweater.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        const outerWear = "T-Shirt";

        function myOutfit() {
        // Altere apenas o código abaixo desta linha
        const outerWear = "sweater";

        // Altere apenas o código acima desta linha
        return outerWear;
        }

        myOutfit();
        </pre>
        </div>
    </section>

    <section id="entender_o_valor_undefined_retornado_de_uma_funcao">
        <header>
            <h2>Entender o valor undefined</h2>
        </header>

        <h3>Entender o valor undefined retornado de uma função</h3>

        <p>Uma função pode incluir a instrução return mas ela não precisa fazer isso. No caso de a função não ter uma instrução return, quando você a chamar, a função processa o código interno, mas o valor retornado é undefined.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        let sum = 0;

        function addSum(num) {
        sum = sum + num;
        }

        addSum(3);
        </pre>
        </div>

        <p>addSum é uma função sem uma instrução return. A função vai alterar a variável global sum, mas o valor retornado da função é undefined.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        let sum = 0;

        function addThree() {
        sum = sum + 3;
        }

        // Altere apenas o código abaixo desta linha
        function addFive() {
        sum += 5;
        }

        // Altere apenas o código acima desta linha

        addThree();
        addFive();
        </pre>
        </div>

    </section>

    <section id="atribuir_com_o_valor_retornado">
        <header>
            <h2>Atribuir com valor retornado</h2>
        </header>

        <h3>Atribuir com valor retornado</h3>

        <p>Se você se lembrar de nossa discussão sobre como armazenar valores com operador de atribuição, tudo à direita do sinal de igual é resolvido antes de o valor ser atribuído. Isso significa que podemos pegar o valor de retorno de uma função e atribuí-lo a uma variável.</p>

        <p>Assuma que temos uma função definida chamada sum, que soma dois números.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        ourSum = sum(5, 12);
        </pre>
        </div>

        <p>Chamar a função sum com os argumentos 5 e 12 produz um valor de retorno de 17. Esse valor de retorno é atribuído à variável ourSum.</p>

        <p>Chame a função processArg com um argumento de 7 e atribui o retorno do seu valor para a variável processed.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        let processed = 0;

        function processArg(num) {
        return (num + 3) / 5;
        }

        // Altere apenas o código abaixo desta linha
        processed = processArg(7)
        </pre>
        </div>

    </section>

    <section id="ficar_na_linha">
        <header>
            <h2>Ficar na linha</h2>
        </header>

        <h3>Ficar na linha</h3>

        <p>Na Ciência da Computação, uma fila é uma estrutura de dados abstrata onde itens são mantidos em ordem. Novos itens podem ser adicionados no final da fila e itens mais antigos são removidos do início da fila.</p>

        <p>Escreva a função nextInLine, que recebe um array (arr) e um número (item) como argumentos.</p>

        <p>Adicione o número no final do array e então remova o primeiro elemento do array.</p>

        <p>A função nextInLine deve, em seguida, retornar o elemento que foi removido.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function nextInLine(arr, item) {
            arr.push(item);
            const removed = arr.shift();
            return removed;
        }

        // Configuração
        let testArr = [1, 2, 3, 4, 5];

        // Exibir o código
        console.log("Before: " + JSON.stringify(testArr));
        console.log(nextInLine(testArr, 6));
        console.log("After: " + JSON.stringify(testArr));
        </pre>
        </div>
    </section>

    <section id="entender-valores-booleanos">
        <header>
            <h2>Entender valores booleanos</h2>
        </header>

        <h3>Entender valores booleanos</h3>

        <p>Outro tipo de dado é o booleano. Booleanos podem ser apenas dois valores: true ou false. Eles basicamente são interruptores pequenos, onde true é ligado e false é desligado. Esses dois estados são mutuamente exclusivos.</p>

        <p>Observação: valores booleanos nunca são escritos com aspas. As strings "true" e "false" não são booleanos e não tem nenhum significado especial em JavaScript.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function welcomeToBooleans() {
          return true;
        }
        </pre>
        </div>
    </section>
    
    <section id="usar-logica-condicional-com-instrucoes-if">
        <header>
            <h2>Usar logica condicional com instrucoes if</h2>
        </header>

        <h3>Usar lógica condicional com instruções if</h3>

        <p>instruções if são usadas para tomar decisões no código. A palavra-chave if diz ao JavaScript para executar o código nas chaves sob certas condições, definidas nos parênteses. Essas condições são conhecidas como condições Boolean e elas só podem ser true ou false.</p>

        <p>Quando a condição for true, o programa executará as instruções dentro das chaves. Quando a condição booleana for false, as instruções dentro das chaves não serão executadas.</p>

        <h3>Pseudocódigo</h3>

        <div class="exemplo">
        <pre>
        if (condição é verdadeira) {
          instrução é executada
        }
        </pre>
        </div>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function test (myCondition) {
          if (myCondition) {
            return "It was true";
          }
          return "It was false";
        }

        test(true);
        test(false);
        </pre>
        </div>

        <p>test(true) retorna a string It was true e test(false) retorna a string It was false.</p>

        <p>Quando test é chamado com valor true, a instrução if avalia myCondition para verificar se é true ou não. Já que é true, a função retorna It was true. Quando chamamos test com um valor de false, myCondition não é true, a instrução nas chaves não é executada e a função retorna It was false.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function trueOrFalse(wasThatTrue) {
          if (wasThatTrue) {
            return "Yes, that was true"
          }
          return "No, that was false"
        }
        </pre>
        </div>
    </section>
    
    <section id="comparar_com_operador_de_igualdade">
        <header>
            <h2>Comparar com operador de igualdade</h2>
        </header>

        <h3>Comparar com operador de igualdade</h3>

        <p>Há muitos operadores de comparação em JavaScript. Todos esses operadores retornam um valor booleano true ou false.</p>

        <p>O operador mais básico é o operador de igualdade ==. O operador de igualdade compara dois valores e retorna true se eles são equivalentes ou false se não são. Observe que o operador de igualdade é diferente do operador de atribuição (=), que atribui o valor à direita do operador para uma variável à esquerda.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function equalityTest(myVal) {
        if (myVal == 10) {
            return "Equal";
        }
        return "Not Equal";
        }
        </pre>
        </div>

        <p>Se myVal é igual a 10, o operador de igualdade retorna true, assim o código nas chaves será executado e a função retornará Equal. Caso contrário, a função retornará Not Equal. Para que o JavaScript possa comparar dois tipos de dados diferentes (por exemplo, numbers e strings), deve converter um tipo para outro. Isto é conhecido como coerção de tipo (casting ou type coercion). No entanto, uma vez que a faça, você pode comparar os termos da seguinte forma:</p>

<pre>
    
1   ==  1  // true
1   ==  2  // false
1   == '1' // true
"3" ==  3  // true
</pre>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        function testEqual(val) {
        if (val == 12) { 
            return "Equal";
        }
        return "Not Equal";
        }

        testEqual(10);
        </pre>
        </div>
    </section>
    
    <section id="comparar_com_operador_de_igualdade_estrita">
        <header>
            <h2>Comparar com operador de igualdade estrita</h2>
        </header>

        <h3>Comparar com operador de igualdade estrita</h3>

        <p>Igualdade estrita (===) é a contrapartida do operador de igualdade (==). No entanto, ao contrário do operador de igualdade, que tenta converter ambos os valores em comparação a um tipo comum, o operador estrito de igualdade não realiza uma conversão de tipo.</p>

        <p>Se os valores que são comparados tiverem valores diferentes, são considerados desiguais, e o operador de igualdade estrito retornará falso.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        3 ===  3  // true
        3 === '3' // false
        </pre>
        </div>

        <p>No segundo exemplo, 3 é um tipo de Number e '3' é um tipo String.</p>


        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        function testStrict(val) {
        if (val === 7) {
            return "Equal";
        }
        return "Not Equal";
        }

        testStrict(10);
        </pre>
        </div>
    </section>
    
    <section id="praticar_comparacao_diferentes_valores">
        <header>
            <h2>Praticar comparacao diferentes valores</h2>
        </header>

        <h3>Praticar a comparação de diferentes valores</h3>

        <p>Nos últimos dois desafios, aprendemos sobre o operador de igualdade (==) e o operador de igualdade estrita (===). Vamos fazer uma breve revisão e praticar usando esses operadores mais uma vez.</p>

        <p>Se os valores sendo comparados não são do mesmo tipo, o operador de igualdade fará a conversão de tipo e, então, avaliará os valores. No entanto, o operador de igualdade estrita vai comparar ambos os tipos de dados e os valores, sem converter de um tipo para outro.</p>

        <h3>Exemplos</h3>

        <p>3 == '3' retorna true porque JavaScript faz a conversão de tipo de string para número. 3 === '3' retorna false porque os tipos são diferentes e não é feita a conversão de tipo.</p>

        <p>Observação: em JavaScript, você pode determinar o tipo de uma variável ou de um valor, com operador typeof, como vemos a seguir:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        typeof 3
        typeof '3'  
        </pre>
        </div>

        <p>typeof 3 retorna a string number e typeof '3' retorna a string string.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        function compareEquality(a, b) {
        if (a === b) {
            return "Equal";
        }
        return "Not Equal";
        }

        compareEquality(10, "10");
        </pre>
        </div>
    </section>
    
    <section id="comparar_com_operador_desigualdade">
        <header>
            <h2>Comparar com operador desigualdade</h2>
        </header>
        <h3>Comparar com operador de desigualdade</h3>

        <p>O operador de desigualdade (!=) é o oposto do operador de igualdade. Significa que não é igual e retorna false onde a igualdade retornaria true e vice-versa. Tal como o operador de igualdade, o operador de desigualdade converterá os tipos de dados de valores enquanto compara.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        1 !=  2    // true
        1 != "1"   // false
        1 != '1'   // false
        1 != true  // false
        0 != false // false
        </pre>
        </div>


        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        function testNotEqual(val) {
        if (val != 99) { // Altere esta linha
            return "Not Equal";
        }
        return "Equal";
        }

        testNotEqual(10);
        </pre>
        </div>
    </section>

    <section id="comparar_com_o_operador_desigualdade_estrita">
        <header>
            <h2>Comparar com operador de desigualdade estrita</h2>
        </header>

        <h3>Comparar com o operador de desigualdade estrita</h3>

        <p>O operador de desigualdade estrito (!==) é o oposto lógico do operador de igualdade estrito. Significa que "não é estritamente igual" e retorna false onde a igualdade estrita retornaria true e vice-versa. O operador de desigualdade estrita não converterá tipos de dados.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        3 !==  3  // false
        3 !== '3' // true
        4 !==  3  // true
        </pre>
        </div>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        function testStrictNotEqual(val) {
        if (val !== 17) {
            return "Not Equal";
        }
        return "Equal";
        }

        testStrictNotEqual(10);
        </pre>
        </div>
    </section>
    
    <section id="comparar_com_o_operador_maior_que">
        <header>
            <h2>Comparar com operador maior que</h2>
        </header>

        <h3>Comparar com o operador maior que</h3>

        <p>O operador maior que (&gt;) compara os valores de dois números. Se o número à esquerda for maior que o número à direita, ele retorna true. Caso contrário, ele retorna false.</p>

        <p>Tal como o operador de igualdade, o operador maior que converterá os tipos de dados de valores enquanto compara.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        5   &gt;  3  // true
        7   &gt; '3' // true
        2   &gt;  3  // false
        '1' &gt;  9  // false
        </pre>
        </div>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function testGreaterThan(val) {
          if (val&gt; 100 ) {
            return "Over 100";
          }

          if (val &gt; 10) {
            return "Over 10";
          }

          return "10 or Under";
        }

        testGreaterThan(10);
        </pre>
        </div>
    </section>
    
    <section id="comparar_com_operador_maior_ou_igual">
        <header>
            <h2>Comparar com operador maior ou igual</h2>
        </header>

        <h3>Comparar com o operador maior ou igual</h3>

        <p>O operador maior ou igual que (&gt;=) compara os valores de dois números. Se o número à esquerda é maior ou igual ao número à direita, ele retorna true. Caso contrário, ele retornará false.

        <p>Tal como o operador de igualdade, o operador maior que converterá os tipos de dados de valores enquanto compara.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        6   &gt;=  6  // true
        7   &gt;= '3' // true
        2   &gt;=  3  // false
        '7' &gt;=  9  // false
        </pre>
        </div>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function testGreaterOrEqual(val) {
        if (val &gt;= 20) {
            return "20 or Over";
        }

        if (val &gt;= 10) {
            return "10 or Over";
        }

        return "Less than 10";
        }

        testGreaterOrEqual(10);
        </pre>
        </div>
    </section>
    
    <section id="comparar_com_operador_menor_que">
        <header>
            <h2>Comparar com operador menor que</h2>
        </header>

        <h3>Comparar com o operador menor que</h3>

        <p>O operador menor que (&lt;) compara os valores de dois números. Se o número à esquerda for menos que o número à direita, retornará true. Caso contrário, retorna false. Assim como o operador de igualdade, o operador menor que converte os tipos de dados enquanto compara.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        2   &lt; 5 // true
        '3' &lt; 7 // true
        5   &lt; 5 // false
        3   &lt; 2 // false
        '8' &lt; 4 // false
        </pre>
        </div>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function testLessThan(val) {
        if (val &lt; 25) {
            return "Under 25";
        }

        if (val &lt; 55) {
            return "Under 55";
        }

        return "55 or Over";
        }

        testLessThan(10);
        </pre>
        </div>
    </section>
    
    <section id="comparar_com_operador_menor_ou_igual">
        <header>
            <h2>Comparar com operador menor ou igual</h2>
        </header>

        <h3>Comparar com o operador menor ou igual</h3>

        <p>O operador menor ou igual (<=) compara os valores de dois números. Se o número à esquerda for menor ou igual ao número à direita, retornará true. Se o número à esquerda for maior que o número a direita, retornará false. Assim como o operador de igualdade, o operador de menor ou igual que converte os tipos de dados.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        4   &lt;= 5 // true
        '7' &lt;= 7 // true
        5   &lt;= 5 // true
        3   &lt;= 2 // false
        '8' &lt;= 4 // false
        </pre>
        </div>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function testLessOrEqual(val) {
        if (val &lt;= 12) {
            return "Smaller Than or Equal to 12";
        }

        if (val &lt;= 24) {
            return "Smaller Than or Equal to 24";
        }

        return "More Than 24";
        }

        testLessOrEqual(10);
        </pre>
        </div>
    </section>

    <section id="comparar_com_operador_logico_and">
        <header>
            <h2>Comparar com o operador lógico AND</h2>
        </header>    

        <h3>Comparar com o operador lógico AND</h3>

        <p>Às vezes, você precisará testar mais de uma coisa de cada vez. O operador lógico AND (&&) retornará true apenas se os operadores à esquerda e à direita forem verdadeiros.</p>

        <p>O mesmo efeito pode ser alcançado aninhando uma instrução if dentro de outro if.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        if (num &gt; 5) {
            if (num &lt; 10) {
                return "Yes";
            }
        }
        return "No";
        </pre>
        </div>

        <p>O código retornará Yes se num for maior que 5 e menor que 10. A mesma lógica pode ser escrita com o operador lógico AND.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        if (num &gt; 5 && num &lt; 10) {
            return "Yes";
        }
        return "No";

        function testLogicalAnd(val) {
        // Altere apenas o código abaixo desta linha

        if (val &lt;= 50 && val &gt;= 25) {
            return "Yes";
        }

        // Altere apenas o código acima desta linha
        return "No";
        }

        testLogicalAnd(10);
        </pre>
        </div>        
    </section>
    
    <section id="comparar_com_operador_logico_or">
        <header>
            <h2>Comparar com o operador lógico OR</h2>
        </header>    
        
        <h3>Comparar com o operador lógico OR</h3>

        <p>O operador lógico OR (||) retorna true se qualquer um dos operandos for true. Caso contrário, retorna false.</p>

        <p>O operador lógico ou é composto por dois símbolos de pipe: (||). Normalmente, ele pode ser encontrado entre as teclas Backspace e Enter.</p>

        <p>O padrão abaixo deve parecer familiar a partir de pontos de passagem anteriores.</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        if (num &gt; 10) {
            return "No";
        }
        if (num &lt; 5) {
            return "No";
        }
        return "Yes";
        </pre>
        </div>

        <p>O código retornará Yes se num estiver entre 5 e 10 (5 e 10 inclusive). A mesma lógica pode ser escrita com o operador lógico OR.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        if (num &gt; 10 || num &lt; 5) {
            return "No";
        }
        return "Yes";
        </pre>
        </div>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function testLogicalOr(val) {
        // Altere apenas o código abaixo desta linha

        if (val &lt; 10 || val &gt; 20) {
            return "Outside";
        }

        // Altere apenas o código acima desta linha
        return "Inside";
        }

        testLogicalOr(15);
        </pre>
        </div>
    </section>
    
    <section id="introduzir_instrucoes_else">
        <header>
            <h2>Introduzir instruções else</h2>
        </header>    

        <h3>Introduzir instruções else</h3>

        <p>Quando uma condição para uma instrução if for verdadeira, o bloco de código seguinte será executado. E quando a condição for falsa? Normalmente, nada aconteceria. Com uma instrução else, um bloco de código alternativo pode ser executado.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        if (num > 10) {
            return "Bigger than 10";
        } else {
            return "10 or Less";
        }
        </pre>
        </div>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function testElse(val) {
            let result = "";
        // Altere apenas o código abaixo desta linha

        if (val > 5) {
            result = "Bigger than 5";
        } else {
            result = "5 or Smaller";
        }

        // Altere apenas o código acima desta linha
        return result;
        }

        testElse(4);
        </pre>
        </div>        
    </section>
    
    <section id="introduzir_instrucoes_else_if">
        <header>
            <h2>Introduzir instruções else if</h2>
        </header>    
        
        <h3>Introduzir instruções else if</h3>

        <p>Se você tem múltiplas condições que precisam ser resolvidas, você pode encadear as instruções if junto com instruções else if.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        if (num &lt; 15) {
            return "Bigger than 15";
        } else if (num &lt; 5) {
            return "Smaller than 5";
        } else {
            return "Between 5 and 15";
        }
        </pre>
        </div>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function testElseIf(val) {
            if (val &gt; 10) {
                return "Greater than 10";
            } else if (val &lt; 5) {
                return "Smaller than 5";
            } else {
                return "Between 5 and 10";
            }
        }

        testElseIf(7);
        </pre>
        </div>
    </section>
    
    <section id="usar_a_ordem_logica_em_instrucoes_if_else">
        <header>
            <h2>Usar a ordem lógica em instruções if else</h2>
        </header>    
        
        <h3>Usar a ordem lógica em instruções if else</h3>

        <p>A ordem é importante em instruções if e else if.</p>

        <p></p>A função é executada de cima para baixo, então você deve ser cuidadoso com qual instrução vem primeiro.</p>

        <p>Tomemos como exemplo estas duas funções.</p>

        <p>Aqui está a primeira:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function foo(x) {
            if (x &lt; 1) {
                return "Less than one";
            } else if (x &lt; 2) {
                return "Less than two";
            } else {
                return "Greater than or equal to two";
            }
        }
        </pre>
        </div>

        <p>A segunda apenas altera a ordem das instruções if e else if:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function bar(x) {
            if (x &lt; 2) {
                return "Less than two";
            } else if (x &lt; 1) {
                return "Less than one";
            } else {
                return "Greater than or equal to two";
            }
        }
        </pre>
        </div>

        <p>Embora as duas funções pareçam praticamente idênticas, se passarmos um número para ambas, teremos saídas diferentes.</p>

        foo(0)<br>
        bar(0)<br>

        <p>foo(0) retornará a string Less than one e bar(0) retornará a string Less than two.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function orderMyLogic(val) {
            if (val &lt; 5) {
                return "Less than 5";
            } else if (val &lt; 10) {
                return "Less than 10";
            } else {
                return "Greater than or equal to 10";
            }
        }

        orderMyLogic(7);
        </pre>
        </div>
    </section>
    
    <section id="encadear_instrucoes_if_else">
        <header>
            <h2>Encadear instruções if else</h2>
        </header>    

        <h3>Encadear instruções if else</h3>

        <p>Instruções if/else podem ser encadeadas por uma lógica complexa. Aqui está o pseudocódigo de várias instruções encadeadas if/else if:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        if (condition1) {
        statement1
        } else if (condition2) {
        statement2
        } else if (condition3) {
        statement3
        . . .
        } else {
        statementN
        }
        </pre>
        </div>

        <p>Escreva instruções encadeadas if/else if para atender às seguintes condições:</p>

        num &lt; 5 - retorna Tiny<br>
        num &lt; 10 - retorna Small<br>
        num &lt; 15 - retorna Medium<br>
        num &lt; 20 - retorna Large<br>
        num &gt;= 20 - retorna Huge<br>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function testSize(num) {
            // Altere apenas o código abaixo desta linha
            if (num &lt; 5) {
                return "Tiny";
            } else if (num &lt; 10) {
                return "Small";
            } else if (num &lt; 15) {
                return "Medium";
            } else if (num &lt; 20) {
                return "Large";
            } else if (num &gt;= 20) {
                return "Huge";
            }

            return "Change Me";
            // Altere apenas o código acima desta linha
        }

        testSize(7);
        </pre>
        </div>        
    </section>
    
    <section id="jogar_golfe_de_codigo">
        <header>
            <h2>Jogar golfe de código</h2>
        </header>    

        <h3>Jogar golfe de código</h3>

        <p>No jogo de golfe, cada buraco tem um par, significando o número médio de strokes que se espera que golfista faça a fim de derrubar a bola no buraco para completar a jogada. Dependendo da distância acima ou abaixo de par que seu número de strokes estiver, há diferentes apelidos.</p>

        <p>Sua função receberá os argumentos par e strokes. Retorne a string correta de acordo com esta tabela que lista os strokes em ordem de prioridade; superior (mais alta) para o final (mais baixo):</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        Strokes	Retorno
        1	"Hole-in-one!"
        &lt;= par - 2	"Eagle"
        par - 1	"Birdie"
        par	"Par"
        par + 1	"Bogey"
        par + 2	"Double Bogey"
        &gt;= par + 3	"Go Home!"
        </pre>
        </div> 

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const names = ["Hole-in-one!", "Eagle", "Birdie", "Par", "Bogey", "Double Bogey", "Go Home!"];

        function golfScore(par, strokes) {
        // Altere apenas o código abaixo desta linha
            if (( par == 4) && (strokes == 1)) {
                return "Hole-in-one!";
            }
            else if (( par == 4) && (strokes == 2)) {
                return "Eagle";
            }
            else if (( par == 5) && (strokes == 2)) {
                return "Eagle";
            }
            else if (( par == 4) && (strokes == 3)) {
                return "Birdie";
            }
            else if (( par == 4) && (strokes == 4)) {
                return "Par";
            }
            else if (( par == 1) && (strokes == 1)) {
                return "Hole-in-one!";
            }
            else if (( par == 5) && (strokes == 5)) {
                return "Par";
            }
            else if (( par == 4) && (strokes == 5)) {
                return "Bogey";
            }
            else if (( par == 4) && (strokes == 6)) {
                return "Double Bogey";
            }
            else if (( par == 4) && (strokes == 7)) {
                return "Go Home!";
            }
            else if (( par == 5) && (strokes == 9)) {
                return "Go Home!";
            }


        return "Change Me";
        // Altere apenas o código acima desta linha
        }

        golfScore(5, 4);
        </pre>
        </div>         
    </section>
    
    <section id="selecionar_entre_varias_opcoes_com_instrucoes_switch">
        <header>
            <h2>Selecionar entre várias opções com instruções switch</h2>
        </header>    
        
        <h3>Selecionar entre várias opções com instruções switch</h3>

        <p>Se você precisar corresponder um valor a muitas opções, pode usar uma instrução switch. Uma instrução switch compara o valor a uma instrução de caso, que define os diversos valores possíveis. Quaisquer instruções JavaScript válidas podem ser executadas dentro de um bloco de caso (case) e serão executadas a partir do primeiro valor de case correspondente até que um break seja encontrado.</p>

        <p>Aqui está um exemplo de uma instrução switch:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        switch (fruit) {
        case "apple":
            console.log("The fruit is an apple");
            break;
        case "orange":
            console.log("The fruit is an orange");
            break;
        }
        </pre>
        </div> 

        <p>Valores case são testados com o operador de igualdade estrita (===). O break diz ao JavaScript parar interromper a execução das instruções. Se o break for omitido, a próxima instrução case será executada.</p>

        <p>Escreva uma instrução switch que testa val e define answer para as seguintes condições:</p>
        1 - alpha<br>
        2 - beta<br>
        3 - gamma<br>
        4 - delta<br>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function caseInSwitch(val) {
        let answer = "";
        // Altere apenas o código abaixo desta linha
        switch (val) {
            case 1:
            return ("alpha");
            break;
            case 2:
            return ("beta");
            break;
            case 3:
            return ("gamma");
            break;
            case 4:
            return ("delta");
            break;
        }

        // Altere apenas o código acima desta linha
        return answer;
        }

        caseInSwitch(1);
        </pre>
        </div> 
    </section>

    <section id="adicionar_uma_opcao_padrão_em_instrucoes_switch">
        <header>
            <h2>Adicionar uma opção padrão em instruções switch</h2>
        </header>
    
        <h3>Adicionar uma opção padrão em instruções switch</h3>

        <p>Na instrução switch, você não deve ser capaz de especificar todos os possíveis valores como instruções case. Ao invés disso, você pode adicionar a instrução default, que será executada se nenhuma instrução case correspondente for encontrada. Pense nisso como a instrução final else em uma cadeia de if/else.<p>

        <p>A instrução default deve ser o último caso.<p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        switch (num) {
        case value1:
            statement1;
            break;
        case value2:
            statement2;
            break;
        ...
        default:
            defaultStatement;
            break;
        }
        </pre>
        </div> 

        <p>Escreva a instrução switch para definir answer para as seguintes condições:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        a - apple
        b - bird
        c - cat
        default - stuff
        </pre>
        </div> 


        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function switchOfStuff(val) {
        let answer = "";
        // Altere apenas o código abaixo desta linha
        switch (val) {
            case ("a"):
            return ("apple");
            break;
            case ("b"):
            return ("bird");
            break;
            case ("c"):
            return ("cat");
            break;
            default:
            return ("stuff");
        }

        // Altere apenas o código acima desta linha
        return answer;
        }

        switchOfStuff(1);
        </pre>
        </div> 
    </section>	
    
    <section id="lidar_com_varias_opções_idênticas_em_instrucoes_switch">
        <header>
            <h2>Lidar com várias opções idênticas em instruções switch</h2>
        </header>

        <h3>Lidar com várias opções idênticas em instruções switch</h3>

        <p>Se a instrução break for omitida de uma instrução case de um switch, as instruções case seguintes serão executadas até que seja encontrado um break. Se você tem várias entradas com a mesma saída, você pode representá-las em uma instrução switch da seguinte forma:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        let result = "";
        switch (val) {
        case 1:
        case 2:
        case 3:
            result = "1, 2, or 3";
            break;
        case 4:
            result = "4 alone";
        }
        </pre>
        </div> 

        <p>Todos os casos para 1, 2 e 3 vão produzir o mesmo resultado.</p>

        <p>Escreva uma instrução para definir answer para os seguintes intervalos:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        1-3 - Low
        4-6 - Mid
        7-9 - High
        </pre>
        </div> 

        <p>Observação: você precisará ter uma instrução case para cada número no intervalo.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function sequentialSizes(val) {
        let answer = "";
        // Altere apenas o código abaixo desta linha
        switch(val) {
            case 1:
            case 2:
            case 3:
            return ("Low");
            break;
            case 4:      
            case 5:      
            case 6:
            return ("Mid");
            break;
            case 7:      
            case 8:      
            case 9:
            return ("High");
            break;
        }


        // Altere apenas o código acima desta linha
        return answer;
        }

        sequentialSizes(1);
        </pre>
        </div>     
    </section>	
    
    <section id="substituir_cadeias_de_if_else_por_switch">
        <header>
            <h2>Substituir cadeias de if else por switch</h2>
        </header>

        <h3>Substituir cadeias de if else por switch</h3>

        <p>Se você tiver muitas opções para escolher, uma instrução switch pode ser mais fácil de escrever do que muitas instruções if/else if encadeadas. O seguinte:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        if (val === 1) {
        answer = "a";
        } else if (val === 2) {
        answer = "b";
        } else {
        answer = "c";
        }
        </pre>
        </div> 

        <p>pode ser substituído por:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        switch (val) {
        case 1:
            answer = "a";
            break;
        case 2:
            answer = "b";
            break;
        default:
            answer = "c";
        }
        </pre>
        </div> 

        <p>Altere a cadeia de instruções if/else if por um comando switch.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function chainToSwitch(val) {
        let answer = "";
        // Altere apenas o código abaixo desta linha

        switch (val) {
            case ("bob"):    
            answer = "Marley";
            break;
            case 42:    
            answer = "The Answer";
            break;
            case 1:  
            answer = "There is no #1";
            break
            case 99:    
            answer = "Missed me by this much!";
            break;
            case 7:    
            answer = "Ate Nine";
            break;
        }

        // Altere apenas o código acima desta linha
        return answer;
        }

        chainToSwitch(7);
        </pre>
        </div>    
    </section>	
    
    <section id="retornar_valores_booleanos_das_funcoes">
        <header>
            <h2>Retornar valores booleanos das funções</h2>
        </header>

        <h3>Retornar valores booleanos das funções</h3>

        <p>Você pode se lembrar de Comparação com o operador de igualdade, em que todos os operadores de comparação retornam um valor booleano true ou false.</p>

        <p>Às vezes, as pessoas usam uma instrução if/else para fazer uma comparação, dessa forma:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function isEqual(a, b) {
        if (a === b) {
            return true;
        } else {
            return false;
        }
        }
        </pre>
        </div> 

        <p>Mas há uma forma melhor de fazer isso. Já que === retorna true ou false, podemos retornar o resultado da comparação:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function isEqual(a, b) {
        return a === b;
        }
        </pre>
        </div> 

        <p>Corrija a função isLess para remover as instruções if/else.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function isLess(a, b) {
        // Altere apenas o código abaixo desta linha
        return a <= b;
        // Altere apenas o código acima desta linha
        }

        document.write(isLess(10, 15));
        </pre>
        </div> 
    </section>	
    
    <section id="retornar_o_padrão_inicial_para_funcoes">
        <header>
            <h2>Retornar o padrão inicial para funções</h2>
        </header>

        <h3>Retornar o padrão inicial para funções</h3>

        <p>Quando uma instrução return é alcançada, a execução da função atual para e retorna o código para o local da chamada da função.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function myFun() {
        console.log("Hello");
        return "World";
        console.log("byebye")
        }
        myFun();
        </pre>
        </div> 

        <p>O código acima exibirá no console a string Hello, e retorna a string World. A string byebye nunca vai ser exibida no console, porque a função termina na instrução return.</p>

        <p>Modifique a função abTest para que se a ou b forem menores que 0 a função irá imediatamente terminar retornando o valor de undefined.</p>

        <h3>Dica</h3>
        <p>Lembre-se de que undefined é uma palavra-chave e não uma string.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        function abTest(a, b) {
        // Altere apenas o código abaixo desta linha

        if (a < 0 || b < 0) {
        return undefined;
        }

        // Altere apenas o código acima desta linha

        return Math.round(Math.pow(Math.sqrt(a) + Math.sqrt(b), 2));
        }

        abTest(2,2);
        </pre>
        </div>    
    </section>	 
    
    <section id="contar_cartas">
        <header>
            <h2>Contar cartas</h2>
        </header>
    
        <h3>Contar cartas</h3>
    
        <p>No jogo de casino Blackjack, um jogador pode determinar se tem uma vantagem sobre a próxima mão da casa, mantendo o número relativo de cartas altas e baixas restantes no baralho. Isso se chama "contar as cartas".</p>
    
        <p>Ter cartas mais altas restantes no baralho favorece o jogador. A cada carta é atribuído um valor de acordo com a tabela abaixo. Quando o contador for positivo, o jogador deve apostar alto. Quando a contagem for zero ou negativa, o jogador deverá apostar baixo.</p>
    
        <div class="exemplo">
        <h4>Mudança na contagem	Cartas:</h4>
        <pre>
        +1	2, 3, 4, 5, 6
        0	7, 8, 9
        -1	10, 'J', 'Q', 'K', 'A'
        </pre>
        </div> 
    
        <p>Você vai escrever uma função de contagem de cartas. A função receberá um parâmetro card, que pode ser um número ou uma string, e incrementar ou decrementar a variável global count de acordo com o valor da carta (veja a tabela). Em seguida, a função retornará a string com o valor atual de contagem (variável count) e a string Bet se a contagem for positiva, ou Hold se a contagem for zero ou negativa. A contagem atual e a decisão do jogador (Bet ou Hold) deve ser separado por um único espaço.</p>
    
        <p>Exemplo de saída: -3 Hold ou 5 Bet</p>
    
        <h3>1 Forma</h3>
    
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        let count = 0;
    
        function cc(card) {
          // Altere apenas o código abaixo desta linha  
            switch (card) {
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
              count++;
              break;
            case 10:
            case "J":
            case "Q":
            case "K":
            case "A":
              count--;
              break;
          }
          if (count > 0) {
            return count + " Bet";
          } else {
            return count + " Hold";
          }
    
          return "Change Me";
          // Altere apenas o código acima desta linha
        }
    
        cc(2); cc(3); cc(7); cc('K'); cc('A');
        </pre>
        </div> 
    
        <h3>2 Forma:</h3>
    
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        let count = 0;
    
        function cc(card) {
          // Only change code below this line
          var regex = /[JQKA]/;
          if (card > 1 && card < 7) {
            count++;
          } else if (card === 10 || regex.test(card)) {
            count--;
          }
    
          if (count > 0) return count + " Bet";
          return count + " Hold";
    
          // Only change code above this line
        }
        </pre>
        </div> 
    </section>

    <section id="criar_objetos">
        <header>
            <h2>Criar objetos</h2>
        </header>
    
        <h3>Criar objetos JavaScript</h3>
    
        <p>Você talvez tenha ouvido o termo objeto antes.</p>
    
        <p>Objetos são similares a arrays, exceto que, ao invés de usar índices para acessar e modificar seus dados, você acessa os dados em objetos através do que se chama propriedades.</p>
    
        <p>Objetos são úteis para armazenar dados de forma estruturada e podem representar objetos do mundo real, como um gato.</p>
    
        <p>Aqui está um exemplo de objeto gato:</p>
    
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const cat = {
          "name": "Whiskers",
          "legs": 4,
          "tails": 1,
          "enemies": ["Water", "Dogs"]
        };
        </pre>
        </div> 
    
        <p>Neste exemplo, todas as propriedades são armazenadas como strings, como name, legs e tails. Porém, você também pode usar números como propriedades. Você pode até omitir as aspas para propriedades de string com uma única palavra, da seguinte forma:</p>
    
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const anotherObject = {
          make: "Ford",
          5: "five",
          "model": "focus"
        };
        </pre>
        </div> 
    
        <p>No entanto, se seu objeto tem quaisquer propriedades que não sejam strings, o JavaScript automaticamente definirá seus tipos como strings.</p>
    
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const myDog = {
          // Altere apenas o código abaixo desta linha
          name: "Tyson",
          legs: 4,
          tails: 1,
          friends: ["Tico", "Teco"]
    
          // Altere apenas o código acima desta linha
        };
        </pre>
        </div>  
    </section>

    <section id="acessar_propriedades_de_objetos_notacao_de_pontos">
        <header>
            <h2>Acessar propriedades de objetos com notação de pontos</h2>
        </header>

        <h3>Acessar propriedades de objetos com notação de pontos</h3>

        <p>Existem duas formas para acessar as propriedades de um objeto: notação de ponto (.) e notação de colchetes ([]), de forma similar a um array.</p>

        <p>Notação de ponto é o que você utiliza quando você sabe o nome da propriedade que você está tentando acessar antecipadamente.</p>

        <p>Aqui está um exemplo usando notação de ponto (.) para ler uma propriedade do objeto:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const myObj = {
          prop1: "val1",
          prop2: "val2"
        };

        const prop1val = myObj.prop1;
        const prop2val = myObj.prop2;
        </pre>
        </div> 

        <p>prop1val teria o valor val1 e prop2val teria o valor val2.

        <p>Leia os valores de propriedade de testObj usando a notação de ponto. Defina a variável hatValue igual à propriedade hat do objeto e defina a variável shirtValue igual à propriedade shirt do objeto.</p>
        <b>Testes</b>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        const testObj = {
          "hat": "ballcap",
          "shirt": "jersey",
          "shoes": "cleats"
        };

        // Altere apenas o código abaixo desta linha
        const hatValue = testObj.hat;      // Altere esta linha
        const shirtValue = testObj.shirt;    // Altere esta linha
        </pre>
        </div> 
    </section>	
    
    <section id="acessar_propriedades_de_objeto_notacao_de_colchetes">
        <header>
            <h2>Acessar propriedades de objeto com notação de colchetes</h2>
        </header>

        <h3>Acessar propriedades de objeto com notação de colchetes</h3>
    
        <p>A segunda forma para acessar as propriedades de um objeto é a notação de colchetes ([]). Se a propriedade do objeto que você está tentando acessar possui um espaço no seu nome, você precisará usar a notação de colchetes.</p>
    
        <p>No entanto, você ainda pode usar a notação de colchetes nas propriedades dos objetos sem espaços.</p>
    
        <p>Aqui está um exemplo usando a notação de colchetes para ler uma propriedade de um objeto:</p>
    
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const myObj = {
          "Space Name": "Kirk",
          "More Space": "Spock",
          "NoSpace": "USS Enterprise"
        };
    
        myObj["Space Name"];
        myObj['More Space'];
        myObj["NoSpace"];
        </pre>
        </div> 
    
        <p>myObj["Space Name"] seria a string Kirk, myObj['More Space'] seria a string Spock e myObj["NoSpace"] seria a string USS Enterprise.</p>
    
        <p>Note que os nomes das propriedades com espaços neles precisam estar entre aspas (simples ou duplas).</p>
    
        <p>Leia os valores das propriedades an entree e the drink de testObj usando notação de colchetes e atribua-os a entreeValue e drinkValue respectivamente.</p>
        <b>Testes</b>
    
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        const testObj = {
          "an entree": "hamburger",
          "my side": "veggies",
          "the drink": "water"
        };
    
        // Altere apenas o código abaixo desta linha
        const entreeValue = testObj["an entree"];   // Altere esta linha
        const drinkValue = testObj['the drink'];    // Altere esta linha
        </pre>
        </div> 
    </section>	
    
    <section id="acessar_propriedades_de_objetos_variaveis">
        <header>
            <h2>Acessar propriedades de objetos com variáveis</h2>
        </header>

        <h3>Acessar propriedades de objetos com variáveis</h3>

        <p>Outro uso de notação de colchetes em objetos é para acessar a propriedade a qual está armazenada como o valor de uma variável. Isso pode ser muito útil para iterar através das propriedades de um objeto ou quando acessando uma tabela de pesquisa.</p>
        
        <p>Aqui está um exemplo de usar uma variável para acessar uma propriedade:</p>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const dogs = {
            Fido: "Mutt",
            Hunter: "Doberman",
            Snoopie: "Beagle"
        };
        
        const myDog = "Hunter";
        const myBreed = dogs[myDog];
        console.log(myBreed);
        </pre>
        </div> 
        
        <p>A string Doberman seria exibida no console.</p>
        
        <p>Observe que não usamos aspas em torno do nome da variável ao usá-la para acessar a propriedade, porque estamos usando o valor da variável, e não o nome.</p>
        
        <p>Defina a variável playerNumber para ser 16. Então, use a variável para procurar o nome do jogador e atribuí-la a player.</p>
        <b>Testes</b>
        
        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        const testObj = {
          12: "Namath",
          16: "Montana",
          19: "Unitas"
        };
        
        // Altere apenas o código abaixo desta linha
        const playerNumber = 16;  // Altere esta linha
        const player = testObj[playerNumber];   // Altere esta linha
        </pre>
        </div> 
    </section>	
    
    <section id="atualizar_propriedades_do_objeto">
        <header>
            <h2>Atualizar propriedades do objeto</h2>
        </header>

        <h3>Atualizar propriedades do objeto</h3>

        <p>Depois de criar um objeto JavaScript, você pode atualizar suas propriedades a qualquer momento, como você atualizaria qualquer outra variável. Você pode usar notação de ponto ou colchete para atualizar.</p>

        <p>Por exemplo, vamos dar uma olhada em ourDog:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const ourDog = {
          "name": "Camper",
          "legs": 4,
          "tails": 1,
          "friends": ["everything!"]
        };
        </pre>
        </div> 

        <p>Como ele é um cachorro particularmente feliz, vamos mudar seu nome para o texto Happy Camper. Veja como atualizamos a propriedade name do objeto: ourDog.name = "Happy Camper"; ou ourDog["name"] = "Happy Camper"; Agora, quando avaliamos ourDog.name, em vez de obter Camper, teremos seu novo nome, Happy Camper.</p>

        <p>Atualize a propriedade name do objeto myDog. Vamos alterar o valor da propriedade name dele de Coder para Happy Coder. Você pode usar notação de ponto ou de colchetes.</p>
        <b>Testes</b>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        const myDog = {
          "name": "Coder",
          "legs": 4,
          "tails": 1,
          "friends": ["freeCodeCamp Campers"]
        };

        // Altere apenas o código abaixo desta linha
        myDog.name = "Happy Coder";
        </pre>
        </div> 
    </section>	
    
    <section id="adicionar_novas_propriedades_para_objeto">
        <header>
            <h2>Adicionar novas propriedades para um objeto</h2>
        </header>

        <h3>Adicionar novas propriedades para um objeto JavaScript</h3>

        <p>Você pode adicionar novas propriedades para um objeto JavaScript existente da mesma forma pela qual você os modificaria.</p>

        <p>Aqui está como adicionaríamos uma propriedade bark para ourDog:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        ourDog.bark = "bow-wow";

        ou

        ourDog["bark"] = "bow-wow";
        </pre>
        </div> 

        <p>Agora, quando acessamos ourDog.bark, nós teremos o seu latido, bow-wow.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const ourDog = {
          "name": "Camper",
          "legs": 4,
          "tails": 1,
          "friends": ["everything!"]
        };

        ourDog.bark = "bow-wow";
        </pre>
        </div> 

        <p>Adicione a propriedade bark para myDog e defina-a para um som de um cachorro, como "woof". Você pode usar tanto notação de ponto quando de colchetes.</p>
        <b>Testes</b>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const myDog = {
          "name": "Happy Coder",
          "legs": 4,
          "tails": 1,
          "friends": ["freeCodeCamp Campers"]
        };

        myDog.bark = "woof";
        </pre>
        </div> 

    </section>	
    
    <section id="excluir_propriedades_de_objeto">
        <header>
            <h2>Excluir propriedades de um objeto </h2>
        </header>

        <h3>Excluir propriedades de um objeto JavaScript</h3>

        <p>Podemos também excluir propriedades de objetos dessa forma:</p>

        <p>delete ourDog.bark;</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const ourDog = {
          "name": "Camper",
          "legs": 4,
          "tails": 1,
          "friends": ["everything!"],
          "bark": "bow-wow"
        };

        delete ourDog.bark;
        </pre>
        </div> 

        <p>Após a última linha mostrada acima, ourDog se parece com:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        {
        "name": "Camper",
          "legs": 4,
          "tails": 1,
          "friends": ["everything!"]
        }
        </pre>
        </div> 

        <p>Exclua a propriedade tails de myDog. Você pode usar tanto notação de ponto quanto notação de colchetes.</p>
        <b>Testes</b>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        const myDog = {
          "name": "Happy Coder",
          "legs": 4,
          "tails": 1,
          "friends": ["freeCodeCamp Campers"],
          "bark": "woof"
        };

        // Altere apenas o código abaixo desta linha
        delete myDog.tails;       
        </pre>
        </div> 
    </section>	
    
    <section id="usar_objetos_para_pesquisas">
        <header>
            <h2>Usar objetos para pesquisas</h2>
        </header>

        <h3>Usar objetos para pesquisas</h3>

        <p>Objetos podem ser pensados como armazenamento de chave/valor, como um dicionário. Se você tem um dado tabular, você pode usar um objeto para pesquisar valores ao invés de uma instrução switch ou uma cadeia de if/else. Isso é mais útil quando você sabe que o seu dado de entrada é limitado para um certo intervalo.</p>

        <p>Aqui está um exemplo de um objeto de artigo:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const article = {
          "title": "How to create objects in JavaScript",
          "link": "https://www.freecodecamp.org/news/a-complete-guide-to-creating-objects-in-javascript-b0e2450655e8/",
          "author": "Kaashan Hussain",
          "language": "JavaScript",
          "tags": "TECHNOLOGY",
          "createdAt": "NOVEMBER 28, 2018"
        };

        const articleAuthor = article["author"];
        const articleLink = article["link"];

        const value = "title";
        const valueLookup = article[value];
        </pre>
        </div> 

        <p>articleAuthor é a string Kaashan Hussain, articleLink é a string https://www.freecodecamp.org/news/a-complete-guide-to-creating-objects-in-javascript-b0e2450655e8/ e valueLookup é a string How to create objects in JavaScript.</p>

        <p>Converta a instrução switch em um objeto chamado lookup. Use-o para pesquisar por val e atribua a string associada para a variável result.</p>
        <b>Testes</b>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        // Configuração
        function phoneticLookup(val) {
        let result = "";

        // Altere apenas o código abaixo desta linha
        const lookup = {
          "alpha": "Adams",
          "bravo": "Boston",
          "charlie": "Chicago",
          "delta": "Denver",
          "echo": "Easy",
          "foxtrot": "Frank"
        }

        result = lookup[val];

        // Altere apenas o código acima desta linha
        return result;
        }

        phoneticLookup("charlie");
        </pre>
        </div> 
    </section>

    <section id="testar_objetos_por_propriedades">
        <header>
            <h2>Testar objetos por propriedades</h2>
        </header>	
        
        <h3>Testar objetos por propriedades</h3>

        <p>Para verificar se uma propriedade em um determinado objeto existe ou não, você pode usar o método</p>
          
        <div class="exemplo">
        <pre>
        .hasOwnProperty()
        someObject.hasOwnProperty(someProperty) 
        </pre>
        </div>
        
        <p>retorna true ou false, dependendo de a propriedade ser encontrada no objeto ou não.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function checkForProperty(object, property) {
        return object.hasOwnProperty(property);
        }

        checkForProperty({ top: 'hat', bottom: 'pants' }, 'top'); // true
        checkForProperty({ top: 'hat', bottom: 'pants' }, 'middle'); // false
        </pre>
        </div> 

        <p>A primeira função checkForProperty retorna true, enquanto a segunda retorna false.</p>

        <p>Modifique a função checkObj para testar se um objeto passado para o parâmetro da função obj contém a propriedade específica passada para o parâmetro da função checkProp. Se a propriedade passada para checkProp for encontrada em obj, retorne o valor dessa propriedade. Se não, retorne Not Found.<p>
        <b>Testes</b>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function checkObj(obj, checkProp) {
        if (obj.hasOwnProperty(checkProp)) {
            return obj[checkProp];
        } else {
            return "Not Found";
        }
        }
        </pre>
        </div> 
    </section>	
    
    <section id="manipular_objetos_complexos">
        <header>
            <h2>Manipular objetos complexos</h2>
        </header>		

        <h3>Manipular objetos complexos</h3>

        <p>Às vezes, você pode querer armazenar dados em uma Estrutura de Dados flexível. Um objeto JavaScript é uma forma de lidar com dados flexíveis. Eles permitem combinações arbitrárias de strings, numbers, booleans, arrays, functions e objects.</p>

        <p>Aqui está um exemplo de estrutura de dados complexas:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const ourMusic = [
        {
            "artist": "Daft Punk",
            "title": "Homework",
            "release_year": 1997,
            "formats": [ 
            "CD", 
            "Cassette", 
            "LP"
            ],
            "gold": true
        }
        ];
        </pre>
        </div> 

        <p>Este é um array que contém um objeto dentro dele. O objeto possui vários pedaços de metadados sobre um álbum. Também possui um array aninhado formats. Se você quiser adicionar mais álbuns, você pode fazer isso adicionando os discos ao array de alto nível. Objetos armazenam dados em uma propriedade, a qual possui um formato de chave-valor. No exemplo acima, "artist": "Daft Punk" é uma propriedade que tem uma chave artist e um valor de Daft Punk.</p>

        <p>Observação: você precisará colocar uma vírgula após cada objeto no array, a não ser que ele seja o último objeto no array.</p>

        <p>Adicione um novo álbum para o array myMusic. Adicione as strings artist e title, o número release_year e um array de strings formats.</p>
        <b>Testes</b>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const myMusic = [
        {
            "artist": "Billy Joel",
            "title": "Piano Man",
            "release_year": 1973,
            "formats": [
            "CD",
            "8T",
            "LP"
            ],
            "gold": true,
        },
        {
            "artist": "Marcus",
            "title": "Aprendendo JavaScript",
            "release_year": 2023,
            "formats": [
            "Curso",
            "Web",
            "Digital"
            ],
            "diamound": true
        }
        ];
        </pre>
        </div> 
    </section>	
    
    <section id="acessar_objetos_aninhados">
        <header>
            <h2>Acessar objetos aninhados</h2>
        </header>	
        
        <h3>Acessar objetos aninhados</h3>

        <p>As subpropriedades de objetos podem ser acessadas ao encadear a notação de ponto e de colchetes.</p>

        <p>Aqui está um objeto aninhado:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const ourStorage = {
        "desk": {
            "drawer": "stapler"
        },
        "cabinet": {
            "top drawer": { 
            "folder1": "a file",
            "folder2": "secrets"
            },
            "bottom drawer": "soda"
        }
        };

        ourStorage.cabinet["top drawer"].folder2;
        ourStorage.desk.drawer;
        </pre>
        </div> 

        <p>ourStorage.cabinet["top drawer"].folder2 seria a string secrets e ourStorage.desk.drawer seria a string stapler.</p>

        <p>Acesse o objeto myStorage e atribua o conteúdo da propriedade glove box para a variável gloveBoxContents. Use notação de ponto para todas as propriedades sempre que possível, caso contrário, use a notação de colchetes.</p>
        <b>Testes</b>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const myStorage = {
        "car": {
            "inside": {
            "glove box": "maps",
            "passenger seat": "crumbs"
            },
            "outside": {
            "trunk": "jack"
            }
        }
        };
        const gloveBoxContents = myStorage.car.inside["glove box"];
        </pre>
        </div> 
    </section>
    
    <section id="acessar_arrays_aninhados">
        <header>
            <h2>Acessar arrays aninhados</h2>
        </header>		

        <h3>Acessar arrays aninhados</h3>

        <p>Como vimos em exemplos anteriores, objetos podem conter tanto objetos aninhados quanto arrays aninhados. Semelhante ao acesso de objetos aninhados, a notação de colchetes pode ser encadeada para se acessar arrays aninhados.</p>

        <p>Aqui está um exemplo de como se acessar um array aninhado:</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const ourPets = [
        {
            animalType: "cat",
            names: [
            "Meowzer",
            "Fluffy",
            "Kit-Cat"
            ]
        },
        {
            animalType: "dog",
            names: [
            "Spot",
            "Bowser",
            "Frankie"
            ]
        }
        ];

        ourPets[0].names[1];
        ourPets[1].names[0];
        </pre>
        </div> 

        <p>ourPets[0].names[1] seria a string Fluffy e ourPets[1].names[0] seria a string Spot.</p>

        <p>Usando a notação de ponto e de colchetes, defina a variável secondTree para o segundo item na lista de trees do objeto myPlants.</p>
        <b>Testes</b>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const myPlants = [
        {
            type: "flowers",
            list: [
            "rose",
            "tulip",
            "dandelion"
            ]
        },
        {
            type: "trees",
            list: [
            "fir",
            "pine",
            "birch"
            ]
        }
        ];

        const secondTree = myPlants[1].list[1];
        </pre>
        </div> 
    </section>	
    
    <section id="exibir_uma_colecao_de_discos">
        <header>
            <h2>Exibir uma coleção de discos</h2>
        </header>	
        
        <h3>Exibir uma coleção de discos</h3>

        <p>Você está criando uma função que ajuda na manutenção de uma coleção de álbuns musicais. A coleção está organizada como um objeto que contém múltiplos álbuns que também são objetos. Cada álbum é representado na coleção com um id único como o nome da propriedade. Dentro de cada objeto de álbum, existem várias propriedades descrevendo informações sobre o álbum. Nem todos os álbuns possuem informações completas.</p>

        <p>A função updateRecords recebe 4 argumentos representados pelos seguintes parâmetros de função:</p>

        <ul>
          <li>records – um objeto contendo vários álbuns individuais</li>
          <li>id – um número que representa um álbum específico no objeto records</li>
          <li>prop – uma string que representa o nome da propriedade do álbum a ser atualizada</li>
          <li>value – uma string contendo informações usadas para atualizar a propriedade do álbum</li>
        </ul>

        <p>Complete a função usando as regras abaixo para modificar o objeto passado para a função.</p>
        
        <ul>
          <li>A função precisa sempre retornar todo o objeto records.</li>
          <li>Se value for uma string vazia, remova a propriedade prop recebida do álbum.</li>
          <li>Se prop não for tracks e value não for uma string vazia, atribua value à prop daquele álbum.</li>
          <li>Se prop for tracks e value não for uma string vazia, você precisa atualizar o array tracks do álbum.</li>
          <li>Primeiro, se o álbum não tiver uma propriedade tracks, atribua a ele um array vazio. Em seguida, adicione value como o último item do array tracks do álbum.</li>
        </ul>

        <p>Observação: uma cópia do objeto recordCollection é usada para testes. Você não deve modificar diretamente o objeto recordCollection.</p>
        <b>Testes</b>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        function updateRecords(records, id, prop, value) {
        if (value === "") {
            delete records[id][prop];
        } else if (prop !== "tracks" && value !== "") {
            records[id][prop] = value;
        } else if (prop === "tracks" && value !== "") {
            if (records[id].hasOwnProperty("tracks") === false) {
            records[id][prop] = [];
            }
            records[id][prop].push(value);
        }
        return records;
        }

        updateRecords(recordCollection, 5439, 'artist', 'ABBA');
        </pre>
        </div> 
    </section>	
    
    <section id="iterar_com_lacos_while">
        <header>
            <h2>Iterar com laços while em JavaScript</h2>
        </header>

        <h3>Iterar com laços while em JavaScript</h3>

        <p>Você pode rodar o mesmo código várias vezes usando um laço.</p>

        <p>O primeiro tipo de laço que aprenderemos é chamado de laço while porque ele rodará enquanto uma condição específica for verdadeira e vai parar uma vez que a condição não for mais verdadeira.</p>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const ourArray = [];
        let i = 0;
        
        while (i &lt; 5) {
            ourArray.push(i);
            i++;
        }    
        </pre>
        </div>

        <p>No código de exemplo acima, o laço while executará por 5 vezes e adicionará os números de 0 até 4 a ourArray.</p>

        <p>Vamos tentar fazer um laço while funcionar empurrando valores para um array.</p>

        <p>Adicione os números de 5 até 0 (inclusive) em ordem descendente para myArray usando um laço while.</p>
        <b>Testes</b>

        <div class="exemplo">
        <h4>exemplo:</h4>
        <pre>
        const myArray = [];
        let i = 5;
        
        while (i >= 0) {
            myArray.push(i);
            i--;
        } 
        
        console.log(myArray);
        </pre>
        </div>
    </section>	

    <section id="iterar_com_lacos_for">
      <header>
          <h2>Iterar com laços for</h2>
      </header>

      <h3>Iterar com laços for JavaScript</h3>

      <p>Você pode rodar o mesmo código várias vezes usando um laço.</p>

      <p>O tipo mais comum de laço JavaScript é chamado de laço for, porque ele é executado por um número especificado de vezes.</p>

      <p>Laços for são declarados com três expressões opcionais separadas por ponto e vírgula:</p>

      <p>for (a; b; c), onde a é a declaração de inicialização, b é a declaração de condição, e c é a expressão final.</p>

      <p>A declaração de inicialização é executada apenas uma vez antes de o laço iniciar. Normalmente, é usada para definir e configurar sua variável de laço.</p>

      <p>A declaração de condição é verificada no início de cada iteração do laço e vai continuar enquanto seu valor for true. Quando a condição for false no início da iteração, o laço vai parar de executar. Isso significa que se a condição de início for falsa, seu laço nunca será executado.</p>

      <p>A expressão final é executada no final de cada iteração do laço, antes da verificação da próxima condição e normalmente é usada para incrementar ou decrementar o contador do laço.</p>

      <p>No exemplo a seguir, inicializamos com i = 0 e iteramos enquanto nossa condição i &lt; 5 for verdadeira. Nós incrementaremos i em 1 em cada iteração do laço com i++ como nossa expressão final.</p>

      <div class="exemplo">
      <h4>exemplo:</h4>
      <pre>    
      const ourArray = [];

      for (let i = 0; i &lt; 5; i++) {
      ourArray.push(i);
      }

      ourArray agora terá o valor de [0, 1, 2, 3, 4].
      </pre>
      </div>

      <p>Use o laço for para adicionar os valores de 1 até 5 dentro de myArray.</p>
      <b>Testes</b>

      <div class="exemplo">
      <h4>exemplo:</h4>
      <pre>    
      const myArray = [];

      // Altere apenas o código abaixo desta linha
      for(let i = 1; i &lt;= 5; i++){
          myArray.push(i);
      }
      
      console.log(myArray);

      [ 1, 2, 3, 4, 5 ]
      </pre>
      </div>    
    </section>

    <section id="iterar_numeros_impares_com_laco_for">
      <header>
          <h2>Iterar números ímpares com laço for</h2>
      </header>

      <h3>Iterar números ímpares com um laço for</h3>

      <p>Laços for não tem de iterar um de cada vez. Ao alterar nossa final-expression, nós podemos contar os números pares.</p>

      <p>Começaremos em i = 0 e um laço while i &lt; 10. Incrementaremos i em 2 a cada iteração com i += 2.</p>

      <div class="exemplo">
      <h4>exemplo:</h4>
      <pre>
      const ourArray = [];

      for (let i = 0; i &lt; 10; i += 2) {
      ourArray.push(i);
      }
      </pre>
      </div> 

      <p>ourArray agora conterá [0, 2, 4, 6, 8]. Vamos mudar nossa initialization para que possamos contar por números ímpares.</p>

      <p>Adicione (push) os números ímpares de 9 até 1 para myArray usando um laço for.</p>
      <b>Testes</b>

      <div class="exemplo">
      <h4>exemplo:</h4>
      <pre>
      // Configuração
      const myArray = [];

      // Altere apenas o código abaixo desta linha
      for(let i = 9; i >= 0; i-= 2){
      myArray.unshift(i);
      }

      console.log(myArray);

      [1, 3, 5, 7, 9]
      </pre>
      </div> 
    </section>

    <section id="contar_para_tras_com_laco_for">
      <header>
          <h2>Contar para trás com laço for</h2>
      </header>

      <h3>Contar para trás com um laço for</h3>

      <p>Um laço for também pode contar pra trás, contanto que possamos definir as condições certas.</p>

      <p>Para decrementar em dois cada iteração, nós precisamos alterar nossa inicialização, condição e expressão final.</p>

      <p>Nós começaremos em i = 10 e vamos iterar enquanto i > 0. Nós decrementamos i por dois em cada iteração com i -= 2.</p>

      <div class="exemplo">
      <h4>exemplo:</h4>
      <pre>
      const ourArray = [];

      for (let i = 10; i &gt; 0; i -= 2) {
      ourArray.push(i);
      }
      </pre>
      </div> 

      <p>ourArray agora vai conter [10, 8, 6, 4, 2]. Vamos mudar nossa inicialização e expressão final para que possamos contar para trás em dois para criar um array de números ímpares decrescentes.</p>

      <p>Adicione (push) os números ímpares de 9 até 1 para myArray usando um laço for.</p>
      <b>Testes</b>

      <div class="exemplo">
      <h4>exemplo:</h4>
      <pre>
      // Configuração
      const myArray = [];

      // Altere apenas o código abaixo desta linha
      for (let i = 9; i &gt; 0; i -= 2) {
      myArray.push(i);
      }

      console.log(myArray);
      [9, 7, 5, 3, 1]
      </pre>
      </div> 
    </section>

    <section id="iterar_atraves_array_laco_for">
      <header>
          <h2>Iterar através de array laço for</h2>
      </header>

      <h3>Iterar através de um array com laço for</h3>

      <p>Uma tarefa comum em JavaScript é para iterar através do conteúdo de um array. Uma forma de fazer isso é com um laço for. Esse código vai exibir cada elemento do array arr no console:</p>

      <div class="exemplo">
      <h4>exemplo:</h4>
      <pre>
      const arr = [10, 9, 8, 7, 6];

      for (let i = 0; i &lt; arr.length; i++) {
      console.log(arr[i]);
      }
      </pre>
      </div>

      <p>Lembre-se de que arrays têm indexação baseada em zero, o que significa que o último índice do array é de length - 1. Nossa condição para esse laço é i &lt; arr.length, que interrompe o laço quando i é igual a length. Nesse caso a última iteração é i === 4, ou seja, quando i se tornar igual a arr.length - 1 e exibir 6 no console. Em seguida, i aumenta para 5, e o laço é interrompido porque i &lt; arr.length é false.</p>

      <p>Declare e inicialize uma variável total como 0. Use um laço for para adicionar o valor de cada elemento do array myArr para total.</p>
      <b>Testes</b>

      <div class="exemplo">
      <h4>exemplo:</h4>
      <pre>
      // Configuração
      const myArr = [2, 3, 4, 5, 6];

      // Altere apenas o código abaixo desta linha
      let total = 0;
      for (let i = 0; i &lt; myArr.length; i++) {
      total += myArr[i];
      }
      console.log(total);
      20
      </pre>
      </div>
    </section>
  </main>

  <footer>
    <p><a id="topo" href="#"><i class="fa-solid fa-arrow-up-from-bracket"></i></a></p>
  </footer>

  <script>
    const navSlide = () => {
      const menuBtn = document.querySelector('.menuBtn');
      const nav = document.querySelector('.nav-links');
      //Fazendo aparecer os itens
      const navLinks = document.querySelectorAll('.nav-links li');
  
      //Fazendo o clique do menu funcionar
      menuBtn.addEventListener('click', () => {
        nav.classList.toggle('nav-active');
  
        //Animações links
        navLinks.forEach((link, index) => {
          if (link.style.animation) {
            link.style.animation = '';
          } else {
            link.style.animation = `navlinkFade 0.5s ease forwards ${index/7+1.5}s`
  
          }
        });
        //Transformando em X
        menuBtn.classList.toggle('toggle');
      });
  
      window.addEventListener('popstate', function() {
      nav.classList.remove('nav-active');
      });
    }
  
    navSlide();
  </script>
</body>
</html>